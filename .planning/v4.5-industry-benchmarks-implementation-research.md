# v4.5 Industry Benchmarks - Implementation Research

**Researched:** 2026-02-05
**Domain:** Admin tools, bulk API fetching, weighted aggregation, comparison UI
**Confidence:** HIGH (based on existing codebase patterns + verified best practices)

---

## Summary

This research covers implementation patterns for the Industry Benchmarks feature. The codebase already has solid foundations: `fetchFacebookAds()` handles rate-limited API calls with pagination, `aggregateDemographics()` performs reach-weighted demographic aggregation, and the dashboard components show comparison patterns.

**Key recommendations:**
1. **Admin protection:** Use simple hardcoded user ID check in API routes (no middleware complexity needed for single-admin tool)
2. **Bulk fetching:** Sequential with delays (1 brand every 2 seconds), reusing existing `fetchFacebookAds()`
3. **Aggregation:** Extend existing weighted average pattern from `facebook-api.ts` to work across brands
4. **Progress feedback:** Server-Sent Events (SSE) for real-time "fetching brand 3/15" updates
5. **Export:** Native TypeScript CSV generation (no library needed)

---

## Admin Route Protection

### Recommendation: Hardcoded Admin Check in API Routes

For a single-admin tool, complex middleware is overkill. Use a simple pattern matching the existing codebase.

**Pattern to use:**

```typescript
// src/app/api/admin/industries/route.ts
import { auth } from '@/auth';
import { NextResponse } from 'next/server';

const ADMIN_USER_ID = process.env.ADMIN_USER_ID || 'demo-user-1';

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Admin check - simple hardcoded ID
  if (session.user.id !== ADMIN_USER_ID) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // ... rest of handler
}
```

**Why not middleware:**
- Feature is admin-only, not user-facing
- Adding role field to User model adds complexity for single-user benefit
- Middleware runs on every request matching pattern (performance cost)
- Existing codebase uses inline session checks, not middleware

**Why not role field:**
- Would require schema migration
- Need to set up role assignment logic
- Overkill for "only Sebastian can use this" requirement

**Environment variable approach:**
```env
# .env
ADMIN_USER_ID=cuid-of-sebastian
```

This keeps admin IDs out of code, allows easy changes, and works in all environments.

**Confidence:** HIGH - matches existing codebase patterns in `src/app/api/dashboard/*`

---

## Bulk Fetching Strategy

### Recommendation: Sequential with Delays (Rate-Limited Pipeline)

The existing `fetchFacebookAds()` already handles pagination and per-country batching. For bulk brand fetching, use sequential execution with delays.

**Pattern to use:**

```typescript
// src/lib/industry-fetcher.ts
import { fetchFacebookAds, type FacebookApiResult } from './facebook-api';

export interface BrandFetchResult {
  pageId: string;
  pageName: string;
  result: FacebookApiResult | null;
  error: string | null;
}

export interface FetchProgress {
  current: number;
  total: number;
  currentBrand: string;
  status: 'fetching' | 'complete' | 'error';
}

export async function fetchBrandsSequentially(
  brands: Array<{ facebookPageId: string; pageName: string }>,
  accessToken: string,
  onProgress?: (progress: FetchProgress) => void,
  delayMs: number = 2000
): Promise<BrandFetchResult[]> {
  const results: BrandFetchResult[] = [];
  const euCountries = ['DE', 'FR', 'NL', 'SE', 'FI', 'DK', 'ES', 'IT', 'PL', 'BE'];

  for (let i = 0; i < brands.length; i++) {
    const brand = brands[i];

    onProgress?.({
      current: i + 1,
      total: brands.length,
      currentBrand: brand.pageName,
      status: 'fetching'
    });

    const result = await fetchFacebookAds({
      accessToken,
      pageId: brand.facebookPageId,
      countries: euCountries,
      limit: 500,
      activeStatus: 'ACTIVE',
    });

    if (result.success) {
      results.push({
        pageId: brand.facebookPageId,
        pageName: result.pageName || brand.pageName,
        result,
        error: null,
      });
    } else {
      results.push({
        pageId: brand.facebookPageId,
        pageName: brand.pageName,
        result: null,
        error: result.error,
      });
    }

    // Delay between brands to avoid rate limits
    if (i < brands.length - 1) {
      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }

  return results;
}
```

**Why sequential with delays (not parallel):**
1. Facebook API has rate limits (~200 calls/hour for Graph API)
2. Each brand fetch = 10+ API calls (per-country + pagination)
3. 15 brands in parallel = potential 150+ simultaneous calls = rate limit hit
4. Sequential with 2s delay = ~30 seconds for 15 brands, well within limits

**Why reuse `fetchFacebookAds()`:**
- Already handles pagination, country batching, deduplication
- Already returns `FacebookApiResult` with all needed data
- No need to write new Facebook API code

**Gotcha:** The existing `fetchFacebookAds()` can take 5-10 seconds per brand (pagination + per-country fetching). Plan for 2-3 minute total benchmark generation time for 15 brands.

**Confidence:** HIGH - based on existing `fetchFacebookAds()` implementation

---

## Aggregation Patterns

### Recommendation: Extend Existing Weighted Average Pattern

The codebase already has reach-weighted demographic aggregation in `src/lib/facebook-api.ts` lines 287-360. Extend this pattern to work across multiple brands.

**Existing pattern (single brand):**
```typescript
// From facebook-api.ts - aggregates demographics across ads for ONE brand
function aggregateDemographics(ads: FacebookAdResult[]): AggregatedDemographics | null {
  // Uses reach as weight, default to 1 if no reach
  const weight = ad.euTotalReach > 0 ? ad.euTotalReach : 1;
  totalWeight += weight;

  // Aggregate age-gender breakdown
  for (const item of ad.demographics.ageGenderBreakdown) {
    const weightedValue = (item.percentage / 100) * weight;
    ageMap.set(item.age, (ageMap.get(item.age) || 0) + weightedValue);
  }
}
```

**New pattern for industry aggregation:**

```typescript
// src/lib/industry-aggregator.ts
import type { FacebookApiResult, AggregatedDemographics } from './facebook-api';

export interface IndustryAggregatedDemographics extends AggregatedDemographics {
  brandsIncluded: number;
  brandsWithDemographics: number;
}

export function aggregateIndustryDemographics(
  brandResults: Array<{ result: FacebookApiResult }>
): IndustryAggregatedDemographics | null {
  // Use BRAND-LEVEL aggregated demographics, weighted by brand's total reach
  const ageMap = new Map<string, number>();
  const genderMap = new Map<string, number>();
  const regionMap = new Map<string, number>();
  let totalWeight = 0;
  let brandsWithDemographics = 0;

  for (const { result } of brandResults) {
    if (!result.aggregatedDemographics) continue;

    brandsWithDemographics++;
    const demo = result.aggregatedDemographics;

    // Weight by brand's total reach
    const brandReach = demo.totalReachAnalyzed;
    totalWeight += brandReach;

    // Aggregate age breakdown
    for (const item of demo.ageBreakdown) {
      const weightedValue = (item.percentage / 100) * brandReach;
      ageMap.set(item.age, (ageMap.get(item.age) || 0) + weightedValue);
    }

    // Aggregate gender breakdown
    for (const item of demo.genderBreakdown) {
      const weightedValue = (item.percentage / 100) * brandReach;
      genderMap.set(item.gender, (genderMap.get(item.gender) || 0) + weightedValue);
    }

    // Aggregate region breakdown
    for (const item of demo.regionBreakdown) {
      const weightedValue = (item.percentage / 100) * brandReach;
      regionMap.set(item.region, (regionMap.get(item.region) || 0) + weightedValue);
    }
  }

  if (totalWeight === 0) return null;

  // Convert back to percentages
  const ageBreakdown = Array.from(ageMap.entries())
    .map(([age, value]) => ({ age, percentage: (value / totalWeight) * 100 }))
    .sort((a, b) => b.percentage - a.percentage);

  const genderBreakdown = Array.from(genderMap.entries())
    .map(([gender, value]) => ({ gender, percentage: (value / totalWeight) * 100 }))
    .sort((a, b) => b.percentage - a.percentage);

  const regionBreakdown = Array.from(regionMap.entries())
    .map(([region, value]) => ({ region, percentage: (value / totalWeight) * 100 }))
    .sort((a, b) => b.percentage - a.percentage);

  return {
    ageBreakdown,
    genderBreakdown,
    ageGenderBreakdown: [], // Compute if needed
    regionBreakdown,
    totalReachAnalyzed: totalWeight,
    adsWithDemographics: 0, // Not applicable at industry level
    adsWithoutReach: 0,
    brandsIncluded: brandResults.length,
    brandsWithDemographics,
  };
}
```

**Formula verification:**
The weighted average formula is: `Sum(value_i * weight_i) / Sum(weight_i)`

For demographics:
- `value_i` = brand's percentage for age/gender/region
- `weight_i` = brand's total reach
- Result = industry-wide percentage weighted by reach

This means brands with more reach have more influence on the industry average, which is the correct behavior (a brand reaching 1M people should matter more than one reaching 10K).

**Confidence:** HIGH - extends existing proven pattern from codebase

---

## Comparison/Indexing Logic

### Recommendation: Standard Marketing Index Formula

Use the industry-standard Brand Development Index formula: `Index = (Brand Value / Industry Average) * 100`

**Implementation:**

```typescript
// src/lib/benchmark-comparison.ts
export interface ComparisonMetric {
  metric: string;
  brandValue: number;
  industryValue: number;
  index: number;           // 100 = same as industry
  indexLabel: string;      // "2.3x over" or "0.7x under"
  isOverIndex: boolean;
}

export function calculateIndex(brandValue: number, industryValue: number): number {
  if (industryValue === 0) return brandValue > 0 ? 999 : 100;
  return (brandValue / industryValue) * 100;
}

export function formatIndexLabel(index: number): string {
  if (index > 100) {
    const multiplier = index / 100;
    return `${multiplier.toFixed(1)}x over`;
  } else if (index < 100) {
    const multiplier = index / 100;
    return `${multiplier.toFixed(1)}x under`;
  }
  return 'at average';
}

export function compareBrandToIndustry(
  brandDemographics: AggregatedDemographics,
  industryDemographics: AggregatedDemographics
): ComparisonMetric[] {
  const comparisons: ComparisonMetric[] = [];

  // Compare each age range
  for (const industryAge of industryDemographics.ageBreakdown) {
    const brandAge = brandDemographics.ageBreakdown.find(a => a.age === industryAge.age);
    const brandValue = brandAge?.percentage || 0;
    const index = calculateIndex(brandValue, industryAge.percentage);

    comparisons.push({
      metric: `Age ${industryAge.age}`,
      brandValue,
      industryValue: industryAge.percentage,
      index,
      indexLabel: formatIndexLabel(index),
      isOverIndex: index > 100,
    });
  }

  // Compare each gender
  for (const industryGender of industryDemographics.genderBreakdown) {
    const brandGender = brandDemographics.genderBreakdown.find(g => g.gender === industryGender.gender);
    const brandValue = brandGender?.percentage || 0;
    const index = calculateIndex(brandValue, industryGender.percentage);

    comparisons.push({
      metric: `Gender: ${industryGender.gender}`,
      brandValue,
      industryValue: industryGender.percentage,
      index,
      indexLabel: formatIndexLabel(index),
      isOverIndex: index > 100,
    });
  }

  return comparisons;
}
```

**Index interpretation:**
- Index = 100: Brand matches industry average exactly
- Index = 150: Brand over-indexes by 50% (1.5x the industry average)
- Index = 75: Brand under-indexes by 25% (0.75x the industry average)

**UI display pattern:**
```tsx
// In comparison table
<td className={comparison.isOverIndex ? 'text-green-500' : 'text-red-500'}>
  {comparison.index.toFixed(0)} ({comparison.indexLabel})
</td>
```

**Confidence:** HIGH - standard marketing analytics formula

---

## Progress Feedback UI

### Recommendation: Server-Sent Events (SSE)

For real-time "fetching brand 3/15" updates, use SSE. This is simpler than WebSockets and works well with Next.js App Router.

**Server-side (API route):**

```typescript
// src/app/api/admin/industries/[id]/benchmark/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@/auth';
import { prisma } from '@/lib/prisma';
import { fetchBrandsSequentially } from '@/lib/industry-fetcher';

const ADMIN_USER_ID = process.env.ADMIN_USER_ID || 'demo-user-1';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id || session.user.id !== ADMIN_USER_ID) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;

  // Fetch industry with brands
  const industry = await prisma.industry.findUnique({
    where: { id },
    include: { brands: true },
  });

  if (!industry) {
    return NextResponse.json({ error: 'Industry not found' }, { status: 404 });
  }

  const accessToken = process.env.FACEBOOK_ACCESS_TOKEN;
  if (!accessToken) {
    return NextResponse.json({ error: 'Facebook API not configured' }, { status: 500 });
  }

  // Create SSE stream
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      const sendEvent = (data: object) => {
        controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
      };

      try {
        const results = await fetchBrandsSequentially(
          industry.brands.map(b => ({
            facebookPageId: b.facebookPageId,
            pageName: b.pageName || 'Unknown',
          })),
          accessToken,
          (progress) => {
            sendEvent({
              type: 'progress',
              current: progress.current,
              total: progress.total,
              currentBrand: progress.currentBrand,
            });
          },
          2000 // 2 second delay between brands
        );

        // Aggregate and save benchmark
        // ... aggregation logic here ...

        sendEvent({
          type: 'complete',
          benchmarkId: 'new-benchmark-id',
        });
      } catch (error) {
        sendEvent({
          type: 'error',
          message: error instanceof Error ? error.message : 'Unknown error',
        });
      }

      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

**Client-side hook:**

```typescript
// src/hooks/use-benchmark-progress.ts
'use client';

import { useState, useCallback } from 'react';

interface Progress {
  current: number;
  total: number;
  currentBrand: string;
}

export function useBenchmarkProgress() {
  const [progress, setProgress] = useState<Progress | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const generateBenchmark = useCallback(async (industryId: string): Promise<string | null> => {
    setIsGenerating(true);
    setError(null);
    setProgress(null);

    return new Promise((resolve) => {
      const eventSource = new EventSource(`/api/admin/industries/${industryId}/benchmark`);

      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'progress') {
          setProgress({
            current: data.current,
            total: data.total,
            currentBrand: data.currentBrand,
          });
        } else if (data.type === 'complete') {
          eventSource.close();
          setIsGenerating(false);
          resolve(data.benchmarkId);
        } else if (data.type === 'error') {
          eventSource.close();
          setIsGenerating(false);
          setError(data.message);
          resolve(null);
        }
      };

      eventSource.onerror = () => {
        eventSource.close();
        setIsGenerating(false);
        setError('Connection lost');
        resolve(null);
      };
    });
  }, []);

  return { progress, isGenerating, error, generateBenchmark };
}
```

**Progress UI component:**

```tsx
// src/components/admin/benchmark-progress.tsx
'use client';

import { useBenchmarkProgress } from '@/hooks/use-benchmark-progress';

interface BenchmarkProgressProps {
  industryId: string;
  onComplete: (benchmarkId: string) => void;
}

export function BenchmarkProgress({ industryId, onComplete }: BenchmarkProgressProps) {
  const { progress, isGenerating, error, generateBenchmark } = useBenchmarkProgress();

  const handleGenerate = async () => {
    const benchmarkId = await generateBenchmark(industryId);
    if (benchmarkId) {
      onComplete(benchmarkId);
    }
  };

  return (
    <div>
      <button
        onClick={handleGenerate}
        disabled={isGenerating}
        className="btn-primary"
      >
        {isGenerating ? 'Generating...' : 'Generate Benchmark'}
      </button>

      {isGenerating && progress && (
        <div className="mt-4">
          <div className="text-sm text-[var(--text-secondary)]">
            Fetching {progress.currentBrand} ({progress.current}/{progress.total})
          </div>
          <div className="w-full h-2 bg-[var(--bg-tertiary)] rounded-full mt-2">
            <div
              className="h-full bg-[var(--accent-green)] rounded-full transition-all"
              style={{ width: `${(progress.current / progress.total) * 100}%` }}
            />
          </div>
        </div>
      )}

      {error && (
        <p className="mt-2 text-sm text-red-400">{error}</p>
      )}
    </div>
  );
}
```

**Why SSE over alternatives:**
- **vs WebSocket:** SSE is simpler, unidirectional (server to client only), works over HTTP/1.1
- **vs polling:** No wasted requests, real-time updates
- **vs Suspense/streaming:** SSE gives explicit progress events, not just "loading"

**Gotcha:** SSE uses `EventSource` which only works with GET requests. The pattern above uses POST for initiation, but if you need GET-only, pass industry ID as query param.

**Confidence:** MEDIUM - SSE is well-documented, but exact Next.js App Router SSE pattern may vary

---

## Export Implementation

### Recommendation: Native TypeScript CSV Generation

No library needed. Generate CSV in API route, return as downloadable file.

**API route:**

```typescript
// src/app/api/admin/industries/[id]/export/route.ts
import { NextResponse } from 'next/server';
import { auth } from '@/auth';
import { prisma } from '@/lib/prisma';

const ADMIN_USER_ID = process.env.ADMIN_USER_ID || 'demo-user-1';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id || session.user.id !== ADMIN_USER_ID) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;
  const { searchParams } = new URL(request.url);
  const format = searchParams.get('format') || 'csv';

  const industry = await prisma.industry.findUnique({
    where: { id },
    include: {
      brands: true,
      benchmarks: {
        orderBy: { snapshotDate: 'desc' },
        take: 1,
      },
    },
  });

  if (!industry || industry.benchmarks.length === 0) {
    return NextResponse.json({ error: 'No benchmark data' }, { status: 404 });
  }

  const benchmark = industry.benchmarks[0];
  const brandSnapshots = benchmark.brandSnapshotsJson as Array<{
    pageId: string;
    pageName: string;
    totalAds: number;
    totalReach: number;
    estimatedSpend: number;
    videoPercentage: number;
    imagePercentage: number;
    carouselPercentage: number;
  }>;

  if (format === 'json') {
    return NextResponse.json({
      industry: {
        name: industry.name,
        description: industry.description,
      },
      benchmark: {
        date: benchmark.snapshotDate,
        brandsAnalyzed: benchmark.brandsAnalyzed,
        totalAdsFound: benchmark.totalAdsFound,
        avgAdsPerBrand: benchmark.avgAdsPerBrand,
        totalReach: Number(benchmark.totalReach),
        avgReachPerBrand: benchmark.avgReachPerBrand,
        demographics: {
          gender: benchmark.genderBreakdownJson,
          age: benchmark.ageBreakdownJson,
          country: benchmark.countryBreakdownJson,
        },
        creativeMix: {
          video: benchmark.videoPercentage,
          image: benchmark.imagePercentage,
          carousel: benchmark.carouselPercentage,
        },
        brands: brandSnapshots,
      },
    });
  }

  // CSV export
  const csvRows: string[] = [];

  // Header row
  csvRows.push([
    'Brand',
    'Total Ads',
    'Total Reach',
    'Est. Spend (USD)',
    'Video %',
    'Image %',
    'Carousel %',
  ].join(','));

  // Industry aggregate row
  csvRows.push([
    `"${industry.name} (Industry Average)"`,
    benchmark.avgAdsPerBrand.toFixed(0),
    benchmark.avgReachPerBrand.toFixed(0),
    benchmark.avgSpendPerBrand.toFixed(0),
    benchmark.videoPercentage.toFixed(1),
    benchmark.imagePercentage.toFixed(1),
    benchmark.carouselPercentage.toFixed(1),
  ].join(','));

  // Brand rows
  for (const brand of brandSnapshots) {
    csvRows.push([
      `"${brand.pageName}"`,
      brand.totalAds,
      brand.totalReach,
      brand.estimatedSpend.toFixed(0),
      brand.videoPercentage.toFixed(1),
      brand.imagePercentage.toFixed(1),
      brand.carouselPercentage.toFixed(1),
    ].join(','));
  }

  const csvContent = csvRows.join('\n');
  const filename = `${industry.name.replace(/[^a-z0-9]/gi, '-')}-benchmark-${benchmark.snapshotDate.toISOString().split('T')[0]}.csv`;

  return new Response(csvContent, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': `attachment; filename="${filename}"`,
    },
  });
}
```

**CSV security note:** Escape values with quotes to prevent CSV injection. The pattern above wraps string values in quotes.

**Client-side download trigger:**

```tsx
// Simple anchor link
<a
  href={`/api/admin/industries/${industryId}/export?format=csv`}
  download
  className="btn-secondary"
>
  Export CSV
</a>
```

**Why no library:**
- CSV generation is simple string concatenation
- No need for streaming (benchmarks are small, <100 rows)
- Keeps bundle size small

**Confidence:** HIGH - standard pattern, no external dependencies

---

## Recommended Phase Order

Based on dependencies and risk, implement in this order:

### Phase 1: Data Model & CRUD (Day 1, morning)
- Add Prisma schema for Industry, IndustryBrand, IndustryBenchmark
- Basic API routes: create/list/delete industries
- Basic API routes: add/remove brands
- **Risk:** Low - standard CRUD, no API calls

### Phase 2: Admin UI - List & Detail (Day 1, afternoon)
- Industry list page `/admin/industries`
- Industry detail page with brands tab
- Add brand modal (reuse BrandSetupModal pattern)
- **Risk:** Low - follows existing dashboard patterns

### Phase 3: Benchmark Generation (Day 2, morning)
- Industry fetcher with sequential brand fetching
- Industry aggregator for weighted demographics
- Benchmark save logic with brand snapshots
- **Risk:** Medium - bulk API calls, need rate limit testing

### Phase 4: Progress Feedback (Day 2, afternoon)
- SSE endpoint for real-time progress
- useBenchmarkProgress hook
- Progress UI component
- **Risk:** Medium - SSE pattern may need debugging

### Phase 5: Benchmark Display (Day 3, morning)
- Benchmark tab with aggregate charts
- Brand table with individual metrics
- Historical benchmark list
- **Risk:** Low - reuse existing chart/table components

### Phase 6: Comparison View (Day 3, afternoon)
- Brand selector dropdown
- Index calculation logic
- Side-by-side comparison table
- Demographic comparison charts
- **Risk:** Low - math is simple, UI follows existing patterns

### Phase 7: Export (Day 3, end of day)
- CSV export endpoint
- JSON export endpoint
- Download buttons in UI
- **Risk:** Low - simple string/JSON generation

---

## Gotchas & Pitfalls

### 1. BigInt Serialization
**Problem:** Prisma returns `totalReach` as BigInt, which can't be JSON.stringify'd directly.

**Solution:** The codebase already has a serialization helper in `src/app/api/dashboard/overview/route.ts`:
```typescript
function serialize(obj: unknown) {
  return JSON.parse(
    JSON.stringify(obj, (_key, value) =>
      typeof value === 'bigint' ? Number(value) : value
    )
  );
}
```
Use this same pattern for all industry API responses.

### 2. Facebook API Rate Limits
**Problem:** Fetching 15 brands in parallel could hit rate limits.

**Solution:** Sequential fetching with 2-second delays (implemented in bulk fetching strategy).

**Detection:** If you see error code 4 or 17 from Facebook API, you've hit rate limits. Add longer delays.

### 3. Missing Demographics Data
**Problem:** Some brands may have no ads, or ads without demographic data.

**Solution:** Handle gracefully in aggregation:
```typescript
if (!result.aggregatedDemographics) {
  // Skip this brand in demographic aggregation
  // But still count it in totalBrands
}
```

### 4. Empty Industries
**Problem:** Generating benchmark for industry with 0 brands.

**Solution:** Validate before fetching:
```typescript
if (industry.brands.length === 0) {
  return NextResponse.json({ error: 'Industry has no brands' }, { status: 400 });
}
```

### 5. SSE Connection Timeout
**Problem:** Benchmark generation can take 2-3 minutes. Some proxies/load balancers timeout connections.

**Solution:** Send heartbeat events every 30 seconds:
```typescript
const heartbeatInterval = setInterval(() => {
  sendEvent({ type: 'heartbeat' });
}, 30000);
// Clear on completion
```

### 6. Partial Failures
**Problem:** If 1 out of 15 brands fails to fetch, should the whole benchmark fail?

**Solution:** Continue with successful brands, note failures:
```typescript
const successfulResults = results.filter(r => r.result !== null);
const failedBrands = results.filter(r => r.error !== null).map(r => r.pageName);

// Save benchmark with note about failures
benchmark.failedBrandsJson = failedBrands.length > 0 ? failedBrands : null;
```

### 7. Stale Data Reuse
**Problem:** Feature spec mentions "If a brand is in multiple industries, reuse data or fetch separately?"

**Solution:** Always fetch fresh data. Industry benchmarks should reflect current state, not cached data. If needed later, add caching with TTL.

---

## Sources

### Primary (HIGH confidence)
- Existing codebase: `src/lib/facebook-api.ts` - aggregateDemographics pattern
- Existing codebase: `src/app/api/dashboard/snapshots/route.ts` - API route patterns
- Existing codebase: `src/components/dashboard/comparison-table.tsx` - comparison UI patterns

### Secondary (MEDIUM confidence)
- [Long-Running Tasks with Next.js](https://dev.to/bardaq/long-running-tasks-with-nextjs-a-journey-of-reinventing-the-wheel-1cjg) - SSE pattern
- [Real-Time Notifications with SSE in Next.js](https://www.pedroalonso.net/blog/sse-nextjs-real-time-notifications/) - SSE implementation
- [Brand Development Index Guide](https://agilebrandguide.com/wiki/metrics/brand-development-index-bdi/) - Index formula
- [How Different Weighting Methods Work](https://www.pewresearch.org/methods/2018/01/26/how-different-weighting-methods-work/) - Weighted aggregation

### Tertiary (LOW confidence)
- [Next.js Middleware for RBAC](https://www.jigz.dev/blogs/how-to-use-middleware-for-role-based-access-control-in-next-js-15-app-router) - Middleware patterns (not recommended for this use case)

---

## Metadata

**Confidence breakdown:**
- Admin protection: HIGH - matches existing codebase patterns
- Bulk fetching: HIGH - extends existing fetchFacebookAds
- Aggregation: HIGH - extends existing aggregateDemographics
- Comparison indexing: HIGH - standard marketing formula
- Progress feedback: MEDIUM - SSE pattern verified but may need debugging
- Export: HIGH - simple string/JSON generation

**Research date:** 2026-02-05
**Valid until:** 60 days (stable patterns, no fast-moving dependencies)
