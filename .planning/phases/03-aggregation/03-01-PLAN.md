---
phase: 03-aggregation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/demographic-types.ts
  - src/lib/demographic-aggregator.ts
autonomous: true

must_haves:
  truths:
    - "Aggregated demographics type captures age, gender, region breakdowns"
    - "Weighted mean calculation uses reach as weight"
    - "Ads without reach contribute with default weight of 1"
    - "Percentages are normalized to sum to 100%"
  artifacts:
    - path: "src/lib/demographic-types.ts"
      provides: "AggregatedDemographics interface"
      contains: "interface AggregatedDemographics"
    - path: "src/lib/demographic-aggregator.ts"
      provides: "aggregateDemographics function"
      exports: ["aggregateDemographics"]
      min_lines: 80
  key_links:
    - from: "src/lib/demographic-aggregator.ts"
      to: "src/lib/demographic-types.ts"
      via: "import types"
      pattern: "import.*from.*demographic-types"
---

<objective>
Create the demographic aggregation module with pure functions that combine per-ad demographics into weighted summaries.

Purpose: Implements EXTR-04 - weight aggregated demographics by reach/impressions, not just ad count
Output: Type definitions and aggregation functions ready for integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-aggregation/03-RESEARCH.md

@src/lib/demographic-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AggregatedDemographics type</name>
  <files>src/lib/demographic-types.ts</files>
  <action>
Add the AggregatedDemographics interface to demographic-types.ts. Place it after the existing AdLibraryResultWithDemographics interface.

The interface must include:
- ageBreakdown: array of {age: string, percentage: number}
- genderBreakdown: array of {gender: string, percentage: number}
- ageGenderBreakdown: array of {age: string, gender: string, percentage: number}
- regionBreakdown: array of {region: string, percentage: number}
- totalReachAnalyzed: number (sum of weights used)
- adsWithDemographics: number (count of ads that contributed)
- adsWithoutReach: number (count of ads that used default weight)

This preserves the age-gender correlation (research pitfall #3) while also providing simplified breakdowns.
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit src/lib/demographic-types.ts</verify>
  <done>AggregatedDemographics interface exported from demographic-types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create demographic-aggregator.ts module</name>
  <files>src/lib/demographic-aggregator.ts</files>
  <action>
Create src/lib/demographic-aggregator.ts with the following pure functions:

1. **getWeight(ad: AdDataWithDemographics): number**
   - Priority 1: Use euTotalReach if > 0
   - Priority 2: Use (impressionsLower + impressionsUpper) / 2
   - Priority 3: Default to 1 (handles missing reach gracefully per success criteria #3)
   - Return 0 if ad.demographics is null

2. **weightedMean(values: number[], weights: number[]): number**
   - Implement formula: sum(value_i * weight_i) / sum(weight_i)
   - Return 0 if weightSum is 0 (avoid division by zero - research pitfall #1)

3. **normalizeBreakdown<T extends {percentage: number}>(entries: T[]): T[]**
   - If total is within 0.1 of 100, just round to 2 decimals
   - If total is 0, return as-is
   - Otherwise normalize each entry to sum to exactly 100%
   - Use roundTo2Decimals helper (Math.round(n * 100) / 100)

4. **aggregateAgeGender(ads: AdDataWithDemographics[], weights: number[])**
   - Group by age_gender key (e.g., "25-34_male")
   - Calculate weighted mean for each group
   - Return array of {age, gender, percentage}

5. **deriveAgeBreakdown(ageGender: {age, gender, percentage}[])**
   - Sum percentages by age across genders
   - Normalize result

6. **deriveGenderBreakdown(ageGender: {age, gender, percentage}[])**
   - Sum percentages by gender across ages
   - Normalize result

7. **aggregateRegions(ads: AdDataWithDemographics[], weights: number[])**
   - Group by region
   - Calculate weighted mean for each region
   - Return normalized array of {region, percentage}

8. **aggregateDemographics(ads: AdDataWithDemographics[]): AggregatedDemographics**
   - Main entry point
   - Filter to ads with demographics (ad.demographics !== null)
   - Return empty result if no ads with data
   - Calculate weights array
   - Call aggregation helpers
   - Normalize all breakdowns
   - Return complete AggregatedDemographics

9. **emptyResult(): AggregatedDemographics**
   - Return default empty structure with empty arrays and 0 counts

Import types from demographic-types.ts. Do NOT mutate input data - use pure functions throughout (research anti-pattern #5).
  </action>
  <verify>
    - TypeScript compiles: npx tsc --noEmit src/lib/demographic-aggregator.ts
    - Module exports aggregateDemographics: grep "export function aggregateDemographics" src/lib/demographic-aggregator.ts
  </verify>
  <done>
    - aggregateDemographics function exported and compiles
    - All helper functions implemented (getWeight, weightedMean, normalizeBreakdown, etc.)
    - Division by zero handled (returns 0)
    - Missing reach handled (default weight 1)
  </done>
</task>

</tasks>

<verification>
1. Both files compile without errors: `npx tsc --noEmit src/lib/demographic-types.ts src/lib/demographic-aggregator.ts`
2. AggregatedDemographics type is exported
3. aggregateDemographics function is exported
</verification>

<success_criteria>
- AggregatedDemographics interface defined with all required fields
- demographic-aggregator.ts exports aggregateDemographics function
- Weighted mean calculation implemented correctly
- Normalization ensures percentages sum to 100%
- Edge cases handled (no data, no reach, division by zero)
</success_criteria>

<output>
After completion, create `.planning/phases/03-aggregation/03-01-SUMMARY.md`
</output>
