---
phase: 03-aggregation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/demographic-types.ts
  - src/lib/ad-library-scraper.ts
autonomous: false

must_haves:
  truths:
    - "Scraper returns aggregated demographics when scrapeDemographics is true"
    - "High-reach ads influence aggregated results more than low-reach ads"
    - "Result includes both per-ad demographics and aggregated summary"
  artifacts:
    - path: "src/lib/demographic-types.ts"
      provides: "Extended result type with aggregatedDemographics field"
      contains: "aggregatedDemographics"
    - path: "src/lib/ad-library-scraper.ts"
      provides: "Aggregation integration"
      contains: "aggregateDemographics"
  key_links:
    - from: "src/lib/ad-library-scraper.ts"
      to: "src/lib/demographic-aggregator.ts"
      via: "import and call"
      pattern: "import.*aggregateDemographics.*from.*demographic-aggregator"
---

<objective>
Integrate the aggregation module into the scraper so users get aggregated demographic summaries automatically.

Purpose: Complete EXTR-04 by making weighted aggregation available through the existing API
Output: Scraper returns both per-ad demographics and aggregated summary
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-aggregation/03-RESEARCH.md
@.planning/phases/03-aggregation/03-01-SUMMARY.md

@src/lib/demographic-types.ts
@src/lib/demographic-aggregator.ts
@src/lib/ad-library-scraper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend result type and integrate aggregator</name>
  <files>src/lib/demographic-types.ts, src/lib/ad-library-scraper.ts</files>
  <action>
**In demographic-types.ts:**
Add `aggregatedDemographics?: AggregatedDemographics` field to the AdLibraryResultWithDemographics interface. Make it optional for backward compatibility - it's only present when demographics were scraped and aggregated.

**In ad-library-scraper.ts:**
1. Import aggregateDemographics from demographic-aggregator.ts at the top:
   `import { aggregateDemographics } from './demographic-aggregator';`

2. In the `scrapeAdLibrary` function, after building `extendedAds` array (around line 516), call the aggregator:
   ```typescript
   // Aggregate demographics (EXTR-04)
   const aggregatedDemographics = aggregateDemographics(extendedAds);
   ```

3. Include aggregatedDemographics in the return statement (around line 524-534):
   ```typescript
   return {
     success: true,
     pageId,
     pageName,
     ads: extendedAds,
     totalAdsFound: extendedAds.length,
     totalActiveAdsOnPage,
     demographicsScraped,
     demographicsFailed,
     topPerformersAnalyzed: topPerformers.length,
     aggregatedDemographics,  // ADD THIS
   } as AdLibraryResultWithDemographics;
   ```

This integrates aggregation seamlessly - callers get both per-ad data and the weighted summary.
  </action>
  <verify>
    - TypeScript compiles: npx tsc --noEmit src/lib/ad-library-scraper.ts
    - Import present: grep "aggregateDemographics" src/lib/ad-library-scraper.ts
    - Field present in type: grep "aggregatedDemographics" src/lib/demographic-types.ts
  </verify>
  <done>
    - AdLibraryResultWithDemographics includes optional aggregatedDemographics field
    - ad-library-scraper imports and calls aggregateDemographics
    - Aggregated result included in response when scrapeDemographics is true
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Demographic aggregation module integrated with scraper - weighted summaries returned automatically</what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Navigate to the app and enter an Ad Library URL (any page with active ads)
3. Trigger a scrape with demographics enabled (UI may need to support this, or use API directly)
4. Check the response includes `aggregatedDemographics` object with:
   - ageBreakdown (array of age groups with percentages)
   - genderBreakdown (male/female percentages)
   - regionBreakdown (country/region percentages)
   - totalReachAnalyzed, adsWithDemographics, adsWithoutReach metadata

Alternative API test:
```bash
curl -X POST http://localhost:3000/api/scrape-ads \
  -H "Content-Type: application/json" \
  -d '{"url": "https://www.facebook.com/ads/library/?active_status=active&ad_type=all&country=DE&view_all_page_id=SOME_PAGE_ID&media_type=all", "scrapeDemographics": true, "maxDemographicAds": 3}'
```

Verify response JSON contains aggregatedDemographics with weighted percentages.
  </how-to-verify>
  <resume-signal>Type "approved" if aggregated demographics appear in response, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. grep confirms aggregateDemographics is imported and called in scraper
3. grep confirms aggregatedDemographics field exists in result type
4. Manual or API test shows aggregated demographics in response
</verification>

<success_criteria>
- Scraper returns aggregatedDemographics when scrapeDemographics option is true
- Aggregated data shows weighted percentages (high-reach ads influence more)
- Response includes metadata (totalReachAnalyzed, adsWithDemographics, adsWithoutReach)
- All three success criteria from roadmap are met:
  1. Demographics weighted by reach/impressions
  2. High-reach ads contribute more than low-reach ads
  3. Missing data handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-aggregation/03-02-SUMMARY.md`
</output>
