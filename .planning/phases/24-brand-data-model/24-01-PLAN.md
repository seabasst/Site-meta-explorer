---
phase: 24-brand-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/brands/save/route.ts
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Authenticated user can click Save Brand after completing analysis"
    - "Brand name is auto-detected from the Facebook page name (apiResult.pageName)"
    - "Saved brand creates TrackedBrand + BrandSnapshot in a single transaction"
    - "Aggregated demographic snapshot is stored (age, gender, country, reach) — not raw ad data"
    - "Duplicate saves return a 409 error and show a toast"
    - "Tier limits are enforced (free: 3, pro: 10)"
  artifacts:
    - path: "src/app/api/brands/save/route.ts"
      provides: "POST endpoint that creates TrackedBrand + BrandSnapshot atomically"
      exports: ["POST"]
    - path: "src/app/page.tsx"
      provides: "Save Brand button in results header + handleSaveBrand handler"
      contains: "handleSaveBrand"
  key_links:
    - from: "src/app/page.tsx"
      to: "/api/brands/save"
      via: "fetch POST in handleSaveBrand"
      pattern: "fetch.*api/brands/save"
    - from: "src/app/api/brands/save/route.ts"
      to: "prisma.trackedBrand + prisma.brandSnapshot"
      via: "prisma.$transaction"
      pattern: "prisma\\.\\$transaction"
    - from: "src/app/page.tsx"
      to: "src/lib/snapshot-builder.ts"
      via: "import buildSnapshotFromApiResult"
      pattern: "buildSnapshotFromApiResult"
---

<objective>
Add "Save Brand" functionality so users can persist a brand and its demographic snapshot after completing analysis.

Purpose: This is the foundation of v3.0 brand tracking. Users analyze a Facebook page, then save it with one click. The brand identity (name, URL, page ID) and aggregated demographic snapshot (age, gender, country, reach) are stored together.

Output: A new API endpoint at `/api/brands/save` and a "Save Brand" button in the analysis results header.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-brand-data-model/24-RESEARCH.md

Key source files to reference:
@src/app/api/dashboard/competitors/route.ts — Follow this exact auth/validation/response pattern
@src/app/api/dashboard/snapshots/route.ts — Snapshot creation pattern + serializeSnapshot helper
@src/lib/snapshot-builder.ts — buildSnapshotFromApiResult() and SnapshotData type
@src/lib/subscription.ts — getSubscriptionStatus() for tier checking
@src/app/page.tsx — Analysis page where button goes (results header ~line 946, existing handleTrackBrand ~line 176)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/brands/save endpoint</name>
  <files>src/app/api/brands/save/route.ts</files>
  <action>
Create a new API route at `src/app/api/brands/save/route.ts` with a POST handler.

Follow the exact pattern from `src/app/api/dashboard/competitors/route.ts`:

1. **Auth check**: `const session = await auth()` — return 401 if no session user id or email.

2. **Parse body**: Accept `{ facebookPageId, pageName, adLibraryUrl, snapshot }` where snapshot contains the flat SnapshotData fields (with totalReach as a Number, not BigInt — the client converts it). Return 400 if facebookPageId, pageName, or adLibraryUrl missing.

3. **Tier limit check**: Call `getSubscriptionStatus(session.user.email)`. Free users get 3 brands, pro/past_due get 10. Count existing brands with `prisma.trackedBrand.count({ where: { trackerId: session.user.id } })`. Return 403 if at limit.

4. **Duplicate check**: Use `prisma.trackedBrand.findUnique` with composite key `trackerId_facebookPageId: { trackerId: session.user.id, facebookPageId }`. Return 409 with error "Brand already saved" if exists.

5. **Create brand + snapshot in transaction**: Use `prisma.$transaction` to:
   - Create TrackedBrand with `{ facebookPageId, pageName, adLibraryUrl, trackerId: session.user.id }`
   - If snapshot data is provided, create BrandSnapshot with all snapshot fields. Convert `totalReach` to BigInt via `BigInt(snapshot.totalReach)`. Use `Prisma.JsonNull` for null JSON fields (demographicsJson, spendByCountryJson). Set `trackedBrandId: newBrand.id` and `userId: session.user.id`.

6. **Return response**: Return `{ brand }` with 200 status. Use the same `serializeSnapshot` pattern from snapshots/route.ts if returning snapshot data (not strictly needed since we only return the brand object).

Import from: `@/auth`, `@/lib/prisma`, `@/lib/subscription`, `@prisma/client` (for Prisma.JsonNull).

Important: Use the `trackerId` relation (not `ownerId`) for saved brands. This is the 1:many relation that supports multiple brands per user and has the composite unique constraint for duplicate checking.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify the route compiles without type errors. Verify the file exists at the correct path for Next.js App Router to serve it as POST /api/brands/save.
  </verify>
  <done>
POST /api/brands/save endpoint exists, compiles, handles auth (401), validation (400), tier limits (403), duplicates (409), and creates TrackedBrand + BrandSnapshot in a transaction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Save Brand button and handler to analysis page</name>
  <files>src/app/page.tsx</files>
  <action>
Modify `src/app/page.tsx` to add a "Save Brand" button in the results header.

1. **Add import**: Import `buildSnapshotFromApiResult` from `@/lib/snapshot-builder` at the top of the file.

2. **Add state**: Add `const [saving, setSaving] = useState(false);` and `const [brandSaved, setBrandSaved] = useState(false);` alongside the existing state declarations.

3. **Reset brandSaved on new analysis**: In the existing `handleAdLibrarySubmit` function, add `setBrandSaved(false)` at the start (near where other state is reset before a new API call). This ensures a fresh analysis shows the Save button again.

4. **Create handleSaveBrand**: Add a new async function near the existing `handleTrackBrand` (~line 176). Implementation:
   ```
   const handleSaveBrand = async () => {
     if (!apiResult || !session) return;
     setSaving(true);
     try {
       const snapshotData = buildSnapshotFromApiResult(apiResult);
       const res = await fetch('/api/brands/save', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
           facebookPageId: apiResult.pageId,
           pageName: apiResult.pageName || `Page ${apiResult.pageId}`,
           adLibraryUrl,
           snapshot: {
             ...snapshotData,
             totalReach: Number(snapshotData.totalReach), // BigInt -> Number for JSON serialization
           },
         }),
       });
       if (!res.ok) {
         const err = await res.json();
         throw new Error(err.error || 'Failed to save brand');
       }
       toast.success('Brand saved!');
       setBrandSaved(true);
     } catch (err) {
       toast.error(err instanceof Error ? err.message : 'Failed to save brand');
     } finally {
       setSaving(false);
     }
   };
   ```

5. **Add button to results header**: In the results header button group (~line 946, inside the `{apiResult && (` block), add a Save Brand button BEFORE the Export dropdown. Only show when `session` exists and `!brandSaved`. Style it consistently with the existing action buttons (same height, text size, rounded corners).

   Use an emerald color scheme to distinguish it: `bg-emerald-500/20 border border-emerald-500/50 text-emerald-400 hover:bg-emerald-500/30`. Add `data-pdf-hide` attribute so it doesn't appear in PDF exports. Add `min-h-[48px]` for mobile touch target consistency with the other buttons.

   Use a bookmark SVG icon (path: `M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z`).

   When `brandSaved` is true, show a "Saved" state instead with a checkmark icon and muted styling (non-interactive).

   Button text: "Saving..." when `saving` is true, "Save Brand" otherwise. Disable the button while `saving`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify page.tsx compiles. Visually confirm the button appears in the results header by running `npm run dev` and completing an analysis.
  </verify>
  <done>
Save Brand button appears in the results header for authenticated users. Clicking it calls /api/brands/save with brand identity + snapshot data. Success shows toast and button changes to "Saved" state. Errors show toast with message. Button resets on new analysis.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` completes successfully
3. Manual test: Run `npm run dev`, sign in, analyze a Facebook page, click "Save Brand"
   - Should see success toast "Brand saved!"
   - Button should change to "Saved" state
   - Clicking again on a new analysis for the same page should show "Brand already saved" error
4. Database check: After saving, verify TrackedBrand and BrandSnapshot records exist in the database with correct data (pageName from Facebook, demographic snapshot fields populated)
</verification>

<success_criteria>
- Authenticated user sees "Save Brand" button after completing analysis
- Brand name is auto-detected from apiResult.pageName
- Single click creates both TrackedBrand and BrandSnapshot records
- Snapshot stores aggregated demographics (age, gender, country, reach) — not raw ad data
- Duplicate saves handled gracefully (409 + toast)
- Tier limits enforced (free: 3, pro: 10)
- Button shows "Saved" state after successful save
- Button resets when user runs a new analysis
</success_criteria>

<output>
After completion, create `.planning/phases/24-brand-data-model/24-01-SUMMARY.md`
</output>
