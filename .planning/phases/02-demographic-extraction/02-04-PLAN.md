---
phase: 02-demographic-extraction
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/actions/scrape-ad-library.ts
  - src/app/api/scrape-ads/route.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can request demographic extraction via API endpoint"
    - "User can request demographic extraction via server action"
    - "Demographic data is returned when requested"
  artifacts:
    - path: "src/actions/scrape-ad-library.ts"
      provides: "Server action accepting scrapeDemographics option"
      contains: "scrapeDemographics"
    - path: "src/app/api/scrape-ads/route.ts"
      provides: "API route accepting scrapeDemographics option"
      contains: "scrapeDemographics"
  key_links:
    - from: "src/actions/scrape-ad-library.ts"
      to: "scrapeAdLibrary"
      via: "options parameter"
      pattern: "scrapeAdLibrary\\(.*scrapeDemographics"
    - from: "src/app/api/scrape-ads/route.ts"
      to: "scrapeAdLibrary"
      via: "options parameter"
      pattern: "scrapeAdLibrary\\(.*scrapeDemographics"
---

<objective>
Wire API layer to demographic extraction capability

Purpose: The demographic extraction logic is complete in the library layer (Plans 01-03) but unreachable via API. This plan connects the user-facing endpoints to the existing functionality.

Output: Server action and API route accept and pass through scrapeDemographics and maxDemographicAds parameters, making demographic extraction accessible to users.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-demographic-extraction/02-VERIFICATION.md

# Source files to modify
@src/actions/scrape-ad-library.ts
@src/app/api/scrape-ads/route.ts

# Library function signature (already accepts options)
# scrapeAdLibrary(url, debug, { scrapeDemographics?: boolean, maxDemographicAds?: number })
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update server action to accept demographic options</name>
  <files>src/actions/scrape-ad-library.ts</files>
  <action>
    Modify scrapeAdLibraryAction to accept and pass through demographic options:

    1. Add optional parameters to function signature:
       - scrapeDemographics?: boolean
       - maxDemographicAds?: number

    2. Pass options object to scrapeAdLibrary call:
       ```typescript
       return await scrapeAdLibrary(adLibraryUrl, !isProduction, {
         scrapeDemographics,
         maxDemographicAds,
       });
       ```

    The function remains backward compatible - existing callers without these parameters continue to work (options default to undefined, which the library handles).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/actions/scrape-ad-library.ts`</verify>
  <done>Server action accepts scrapeDemographics and maxDemographicAds parameters and passes them to scrapeAdLibrary</done>
</task>

<task type="auto">
  <name>Task 2: Update API route to accept demographic options</name>
  <files>src/app/api/scrape-ads/route.ts</files>
  <action>
    Modify POST handler to accept and pass through demographic options:

    1. Destructure additional fields from request body:
       ```typescript
       const { adLibraryUrl, scrapeDemographics, maxDemographicAds } = await request.json();
       ```

    2. Pass options object to scrapeAdLibrary call:
       ```typescript
       const result = await scrapeAdLibrary(adLibraryUrl, !isProduction, {
         scrapeDemographics,
         maxDemographicAds,
       });
       ```

    No additional validation needed - these are optional parameters with sensible defaults in the library.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/app/api/scrape-ads/route.ts`</verify>
  <done>API route accepts scrapeDemographics and maxDemographicAds in request body and passes them to scrapeAdLibrary</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for both modified files
2. Server action signature includes optional demographic parameters
3. API route destructures demographic parameters from request body
4. Both files pass options object to scrapeAdLibrary call
5. Existing functionality (without demographic options) remains unchanged
</verification>

<success_criteria>
- `scrapeDemographics` parameter appears in both files
- `maxDemographicAds` parameter appears in both files
- Options passed to scrapeAdLibrary in both files
- No TypeScript errors
- Backward compatible (existing callers work without changes)
</success_criteria>

<output>
After completion, create `.planning/phases/02-demographic-extraction/02-04-SUMMARY.md`
</output>
