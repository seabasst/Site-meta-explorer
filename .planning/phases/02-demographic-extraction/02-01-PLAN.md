---
phase: 02-demographic-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ad-library-scraper.ts
  - src/lib/demographic-types.ts
  - src/lib/top-performer-selector.ts
autonomous: true

must_haves:
  truths:
    - "Top-performing ads can be identified by reach or duration"
    - "Demographic data types are defined for age, gender, and region"
    - "AdData interface includes fields for demographic extraction"
  artifacts:
    - path: "src/lib/demographic-types.ts"
      provides: "Type definitions for demographics"
      exports: ["DemographicBreakdown", "RegionBreakdown", "AdDemographics", "AdWithMetrics"]
    - path: "src/lib/top-performer-selector.ts"
      provides: "Top performer selection logic"
      exports: ["selectTopPerformers"]
    - path: "src/lib/ad-library-scraper.ts"
      provides: "Extended AdData interface"
      contains: "adArchiveId"
  key_links:
    - from: "src/lib/top-performer-selector.ts"
      to: "src/lib/demographic-types.ts"
      via: "import AdWithMetrics"
      pattern: "import.*AdWithMetrics.*from.*demographic-types"
---

<objective>
Create type definitions for demographic data and implement top performer selection logic.

Purpose: Establish the data structures and selection algorithm needed before extracting demographics from ad detail pages. Top performer selection ensures we focus scraping effort on the most valuable ads within timeout constraints.

Output: New demographic types file, top performer selector module, extended AdData interface with adArchiveId field.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-demographic-extraction/02-RESEARCH.md

# Existing scraper implementation
@src/lib/ad-library-scraper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demographic type definitions</name>
  <files>src/lib/demographic-types.ts</files>
  <action>
Create new file `src/lib/demographic-types.ts` with the following type definitions:

```typescript
// Age/gender breakdown from API response
export interface DemographicBreakdown {
  age: string;       // e.g., "18-24", "25-34", "35-44", "45-54", "55-64", "65+"
  gender: string;    // "male" | "female" | "unknown"
  percentage: number; // 0-100
}

// Country/region breakdown
export interface RegionBreakdown {
  region: string;    // Country code or region name (e.g., "DE", "FR", "GB")
  percentage: number; // 0-100
}

// Complete demographics for a single ad
export interface AdDemographics {
  adArchiveId: string;
  ageGenderBreakdown: DemographicBreakdown[];
  regionBreakdown: RegionBreakdown[];
  euTotalReach?: number;
  impressionsLower?: number;
  impressionsUpper?: number;
}

// Ad with metrics for top performer selection
export interface AdWithMetrics {
  adArchiveId: string;
  destinationUrl: string | null;
  startedRunning: string | null;
  reachLower?: number;
  reachUpper?: number;
  adCount: number;
}
```

These types follow the structure from research (02-RESEARCH.md lines 69-87).
  </action>
  <verify>
`npx tsc --noEmit` passes without errors. File exists at src/lib/demographic-types.ts.
  </verify>
  <done>
All four interfaces (DemographicBreakdown, RegionBreakdown, AdDemographics, AdWithMetrics) are exported and TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend AdData interface with adArchiveId</name>
  <files>src/lib/ad-library-scraper.ts</files>
  <action>
Modify the existing `AdData` interface in `src/lib/ad-library-scraper.ts` to include:

```typescript
export interface AdData {
  adId: string;
  adArchiveId: string | null;  // ADD THIS - Facebook's archive ID for ad detail pages
  destinationUrl: string | null;
  linkText: string | null;
  startedRunning: string | null;
  adCount: number;
  adLibraryLinks: string[];
}
```

Update the code that creates AdData objects (around line 354-368) to populate adArchiveId:
- Get the first ad archive ID from `urlToAdIds.get(url)` (already tracked)
- Set `adArchiveId: adIds?.size ? Array.from(adIds)[0] : null`

This field is needed for navigating to ad detail pages to extract demographics.
  </action>
  <verify>
`npx tsc --noEmit` passes. The AdData interface includes adArchiveId field.
  </verify>
  <done>
AdData interface has adArchiveId field and existing scraper populates it from the tracked ad archive IDs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement top performer selector</name>
  <files>src/lib/top-performer-selector.ts</files>
  <action>
Create new file `src/lib/top-performer-selector.ts`:

```typescript
import { AdWithMetrics } from './demographic-types';

/**
 * Select top-performing ads for demographic analysis.
 * Prioritizes by reach (if available), then by duration (days running).
 *
 * @param ads - Array of ads with metrics
 * @param maxAds - Maximum number of ads to return (default: 10)
 * @returns Top performing ads sorted by reach then duration
 */
export function selectTopPerformers(
  ads: AdWithMetrics[],
  maxAds: number = 10
): AdWithMetrics[] {
  return ads
    .filter(ad => ad.adArchiveId) // Only ads with archive IDs can be scraped
    .map(ad => {
      // Calculate duration score (days running)
      const durationDays = ad.startedRunning
        ? Math.floor((Date.now() - new Date(ad.startedRunning).getTime()) / (1000 * 60 * 60 * 24))
        : 0;

      // Use midpoint of reach range as reach score
      const reachScore = ad.reachLower && ad.reachUpper
        ? (ad.reachLower + ad.reachUpper) / 2
        : 0;

      return { ...ad, durationDays, reachScore };
    })
    // Sort by reach first (descending), then by duration (descending)
    .sort((a, b) => {
      if (b.reachScore !== a.reachScore) {
        return b.reachScore - a.reachScore;
      }
      return b.durationDays - a.durationDays;
    })
    // Remove computed fields before returning
    .map(({ durationDays, reachScore, ...ad }) => ad)
    .slice(0, maxAds);
}
```

Pattern from research (02-RESEARCH.md lines 159-195). Sorts by reach first since higher-reach ads contribute more to weighted aggregation (Phase 3).
  </action>
  <verify>
`npx tsc --noEmit` passes. Function selectTopPerformers is exported from src/lib/top-performer-selector.ts.
  </verify>
  <done>
selectTopPerformers function correctly filters, scores, sorts, and limits ads. Prioritizes reach over duration.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes
2. Three files exist: demographic-types.ts, top-performer-selector.ts, updated ad-library-scraper.ts
3. Types are importable: `import { AdDemographics } from './demographic-types'` works
4. Selector is importable: `import { selectTopPerformers } from './top-performer-selector'` works
</verification>

<success_criteria>
- DemographicBreakdown, RegionBreakdown, AdDemographics, AdWithMetrics types are exported
- AdData interface has adArchiveId field populated from existing ad archive ID tracking
- selectTopPerformers function sorts by reach then duration and limits to maxAds
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-demographic-extraction/02-01-SUMMARY.md`
</output>
