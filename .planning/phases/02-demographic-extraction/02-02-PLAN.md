---
phase: 02-demographic-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/demographic-extractor.ts
autonomous: true

must_haves:
  truths:
    - "Demographic data can be extracted from API response JSON"
    - "Missing demographic fields do not crash extraction"
    - "Age, gender, and region breakdowns are parsed into structured types"
  artifacts:
    - path: "src/lib/demographic-extractor.ts"
      provides: "Demographic extraction logic"
      exports: ["extractDemographicsFromApiResponse"]
      min_lines: 60
  key_links:
    - from: "src/lib/demographic-extractor.ts"
      to: "src/lib/demographic-types.ts"
      via: "import types"
      pattern: "import.*from.*demographic-types"
---

<objective>
Implement demographic data extraction function that parses Facebook API responses.

Purpose: Create a robust parser that extracts age/gender breakdown and region distribution from Facebook's GraphQL responses. Must handle missing data gracefully since not all ads have demographic information (RELY-02).

Output: demographic-extractor.ts module with extractDemographicsFromApiResponse function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-demographic-extraction/02-RESEARCH.md

# Type definitions (created in parallel plan 01)
# Note: This plan runs in Wave 1 parallel with Plan 01
# Import the types that Plan 01 creates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demographic extractor with flexible traversal</name>
  <files>src/lib/demographic-extractor.ts</files>
  <action>
Create new file `src/lib/demographic-extractor.ts`:

```typescript
import { AdDemographics, DemographicBreakdown, RegionBreakdown } from './demographic-types';

// Internal types for API response parsing
interface ApiDemographicDistribution {
  age: string;
  gender: string;
  percentage: string | number;
}

interface ApiRegionDistribution {
  region: string;
  percentage: string | number;
}

/**
 * Extract demographic data from Facebook API response.
 * Uses recursive traversal to find demographic fields regardless of nesting depth.
 * Returns null if no demographic data found (graceful handling for non-EU ads).
 *
 * @param data - Raw API response (parsed JSON)
 * @param adArchiveId - The ad's archive ID
 * @returns AdDemographics or null if no data found
 */
export function extractDemographicsFromApiResponse(
  data: unknown,
  adArchiveId: string
): AdDemographics | null {
  const result: AdDemographics = {
    adArchiveId,
    ageGenderBreakdown: [],
    regionBreakdown: [],
  };

  function parsePercentage(value: string | number): number {
    if (typeof value === 'number') {
      // If already decimal (0-1), convert to percentage
      return value <= 1 ? value * 100 : value;
    }
    const parsed = parseFloat(value);
    // If parsed value is decimal, convert to percentage
    return parsed <= 1 ? parsed * 100 : parsed;
  }

  function traverse(obj: unknown): void {
    if (!obj || typeof obj !== 'object') return;

    if (Array.isArray(obj)) {
      obj.forEach(item => traverse(item));
      return;
    }

    const record = obj as Record<string, unknown>;

    // Look for demographic_distribution field (age/gender breakdown)
    if (record.demographic_distribution && Array.isArray(record.demographic_distribution)) {
      for (const demo of record.demographic_distribution as ApiDemographicDistribution[]) {
        if (demo.age && demo.gender && demo.percentage !== undefined) {
          result.ageGenderBreakdown.push({
            age: demo.age,
            gender: demo.gender.toLowerCase(),
            percentage: parsePercentage(demo.percentage),
          });
        }
      }
    }

    // Alternative field names for age/gender data
    if (record.age_country_gender_reach_breakdown && Array.isArray(record.age_country_gender_reach_breakdown)) {
      for (const item of record.age_country_gender_reach_breakdown as ApiDemographicDistribution[]) {
        if (item.age && item.gender && item.percentage !== undefined) {
          result.ageGenderBreakdown.push({
            age: item.age,
            gender: item.gender.toLowerCase(),
            percentage: parsePercentage(item.percentage),
          });
        }
      }
    }

    // Look for delivery_by_region or region_distribution (country/region breakdown)
    const regionField = record.delivery_by_region || record.region_distribution;
    if (regionField && Array.isArray(regionField)) {
      for (const region of regionField as ApiRegionDistribution[]) {
        if (region.region && region.percentage !== undefined) {
          result.regionBreakdown.push({
            region: region.region,
            percentage: parsePercentage(region.percentage),
          });
        }
      }
    }

    // Look for EU-specific reach field
    if (typeof record.eu_total_reach === 'number') {
      result.euTotalReach = record.eu_total_reach;
    }
    // Also handle string version
    if (typeof record.eu_total_reach === 'string') {
      const parsed = parseInt(record.eu_total_reach, 10);
      if (!isNaN(parsed)) {
        result.euTotalReach = parsed;
      }
    }

    // Look for impressions range
    if (record.impressions && typeof record.impressions === 'object') {
      const imp = record.impressions as { lower_bound?: string | number; upper_bound?: string | number };
      if (imp.lower_bound !== undefined) {
        result.impressionsLower = typeof imp.lower_bound === 'string'
          ? parseInt(imp.lower_bound, 10)
          : imp.lower_bound;
      }
      if (imp.upper_bound !== undefined) {
        result.impressionsUpper = typeof imp.upper_bound === 'string'
          ? parseInt(imp.upper_bound, 10)
          : imp.upper_bound;
      }
    }

    // Recurse into nested objects
    Object.values(record).forEach(val => traverse(val));
  }

  traverse(data);

  // Return null if no demographic data found (RELY-02: graceful handling)
  if (result.ageGenderBreakdown.length === 0 && result.regionBreakdown.length === 0) {
    return null;
  }

  return result;
}
```

Key implementation notes:
- Recursive traversal handles unknown JSON nesting depths (research open question #1)
- Multiple field name checks handle API variations (demographic_distribution, age_country_gender_reach_breakdown)
- parsePercentage normalizes both decimal (0.15) and percentage (15) formats
- Returns null for ads without demographics (RELY-02 requirement)
- Pattern based on research code example (02-RESEARCH.md lines 271-354)
  </action>
  <verify>
`npx tsc --noEmit` passes. File exists at src/lib/demographic-extractor.ts with extractDemographicsFromApiResponse exported.
  </verify>
  <done>
extractDemographicsFromApiResponse function parses API responses, handles multiple field name variations, normalizes percentages, and returns null when no demographic data is found.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debug logging capability</name>
  <files>src/lib/demographic-extractor.ts</files>
  <action>
Add a debug logging helper to demographic-extractor.ts that can log the first successful API response structure. This helps validate the actual JSON structure at runtime (addresses research open question #1).

Add to the file:

```typescript
// Debug flag - set to true to log first successful extraction
let hasLoggedSample = false;

/**
 * Log a sample API response structure (for debugging/development).
 * Only logs once per session to avoid spam.
 */
export function logSampleResponse(data: unknown, context: string): void {
  if (hasLoggedSample) return;

  if (process.env.NODE_ENV !== 'production') {
    console.log(`[demographic-extractor] Sample ${context} response:`,
      JSON.stringify(data, null, 2).slice(0, 2000) + '...');
    hasLoggedSample = true;
  }
}

/**
 * Reset debug logging (for testing)
 */
export function resetDebugLogging(): void {
  hasLoggedSample = false;
}
```

Modify extractDemographicsFromApiResponse to optionally log when successful:

```typescript
export function extractDemographicsFromApiResponse(
  data: unknown,
  adArchiveId: string,
  debug: boolean = false
): AdDemographics | null {
  // ... existing code ...

  // At the end, before final return:
  if (result.ageGenderBreakdown.length > 0 || result.regionBreakdown.length > 0) {
    if (debug) {
      logSampleResponse(data, `demographics-${adArchiveId}`);
    }
    return result;
  }

  return null;
}
```
  </action>
  <verify>
`npx tsc --noEmit` passes. logSampleResponse and resetDebugLogging are exported.
  </verify>
  <done>
Debug logging capability added to help validate API response structure at runtime. Logs only once per session, only in non-production.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes
2. src/lib/demographic-extractor.ts exists with extractDemographicsFromApiResponse exported
3. Function handles: demographic_distribution, age_country_gender_reach_breakdown, delivery_by_region, region_distribution, eu_total_reach, impressions
4. Returns null when no demographic data found
5. Debug logging available for development
</verification>

<success_criteria>
- extractDemographicsFromApiResponse parses demographics from nested API responses
- Multiple field name variations are handled (Facebook API is not consistent)
- Percentages are normalized to 0-100 range regardless of input format
- Returns null (not throws) when no demographic data found (RELY-02)
- Debug logging available to inspect actual API response structure
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-demographic-extraction/02-02-SUMMARY.md`
</output>
