---
phase: 02-demographic-extraction
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/ad-library-scraper.ts
  - src/lib/demographic-types.ts
autonomous: true

must_haves:
  truths:
    - "User can see age group percentages extracted from ad detail pages"
    - "User can see gender percentages extracted from ad detail pages"
    - "User can see country/region distribution extracted from ad detail pages"
    - "Top-performing ads are automatically selected for analysis"
    - "Scraping continues when demographic data is unavailable for an ad"
  artifacts:
    - path: "src/lib/ad-library-scraper.ts"
      provides: "Extended scraper with demographic extraction"
      exports: ["scrapeAdLibrary", "AdLibraryResult"]
      contains: "scrapeAdDemographics"
    - path: "src/lib/demographic-types.ts"
      provides: "Extended result types"
      contains: "AdLibraryResultWithDemographics"
  key_links:
    - from: "src/lib/ad-library-scraper.ts"
      to: "src/lib/demographic-extractor.ts"
      via: "import extractDemographicsFromApiResponse"
      pattern: "import.*extractDemographicsFromApiResponse.*from"
    - from: "src/lib/ad-library-scraper.ts"
      to: "src/lib/top-performer-selector.ts"
      via: "import selectTopPerformers"
      pattern: "import.*selectTopPerformers.*from"
    - from: "src/lib/ad-library-scraper.ts"
      to: "page.goto ad detail URL"
      via: "navigation loop"
      pattern: "facebook\\.com/ads/library/\\?id="
---

<objective>
Integrate demographic extraction into the main scraper with ad detail page navigation.

Purpose: Wire together the type definitions (Plan 01), extraction function (Plan 02), and top performer selection to create the complete demographic scraping pipeline. This fulfills EXTR-01, EXTR-02, EXTR-03, RELY-02, and RELY-04.

Output: Extended scrapeAdLibrary function that returns demographic data for top-performing ads.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-demographic-extraction/02-RESEARCH.md

# Prior plan summaries (load after they exist)
@.planning/phases/02-demographic-extraction/02-01-SUMMARY.md
@.planning/phases/02-demographic-extraction/02-02-SUMMARY.md

# Existing implementation
@src/lib/ad-library-scraper.ts
@src/lib/demographic-types.ts
@src/lib/demographic-extractor.ts
@src/lib/top-performer-selector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extended result type with demographics</name>
  <files>src/lib/demographic-types.ts</files>
  <action>
Add new result type to `src/lib/demographic-types.ts`:

```typescript
// Add to existing file:

// Extended result that includes demographic data
export interface AdLibraryResultWithDemographics {
  success: true;
  pageId: string;
  pageName: string | null;
  ads: AdDataWithDemographics[];
  totalAdsFound: number;
  totalActiveAdsOnPage: number | null;
  demographicsScraped: number;      // How many ads had demographics extracted
  demographicsFailed: number;        // How many ads failed/had no data
  topPerformersAnalyzed: number;     // How many top performers were analyzed
}

// Extended ad data with demographics
export interface AdDataWithDemographics {
  adId: string;
  adArchiveId: string | null;
  destinationUrl: string | null;
  linkText: string | null;
  startedRunning: string | null;
  adCount: number;
  adLibraryLinks: string[];
  demographics: AdDemographics | null;  // null if extraction failed or not attempted
}

// Type guard for result with demographics
export function hasAdDemographics(ad: AdDataWithDemographics): ad is AdDataWithDemographics & { demographics: AdDemographics } {
  return ad.demographics !== null;
}
```

This provides clean types for the extended scraper result that Phase 3 (aggregation) and Phase 4 (display) will consume.
  </action>
  <verify>
`npx tsc --noEmit` passes. AdLibraryResultWithDemographics and AdDataWithDemographics are exported.
  </verify>
  <done>
Extended result types added with demographic fields and success/failure tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ad detail page scraping function</name>
  <files>src/lib/ad-library-scraper.ts</files>
  <action>
Add the following to `src/lib/ad-library-scraper.ts` AFTER the existing imports:

```typescript
import { extractDemographicsFromApiResponse } from './demographic-extractor';
import { selectTopPerformers } from './top-performer-selector';
import { AdDemographics, AdWithMetrics, AdDataWithDemographics, AdLibraryResultWithDemographics } from './demographic-types';
```

Add a new function to scrape demographics from a single ad detail page:

```typescript
/**
 * Scrape demographics from a single ad detail page.
 * Navigates to the ad's detail page and captures demographic data from API responses.
 * Returns null if demographics unavailable (graceful degradation).
 */
async function scrapeAdDemographics(
  page: Page,
  adArchiveId: string,
  debug: boolean = false
): Promise<AdDemographics | null> {
  const demographicsMap: Map<string, AdDemographics> = new Map();

  // Set up response listener for this ad
  const responseHandler = async (response: HTTPResponse) => {
    const url = response.url();

    if (url.includes('/api/graphql') || url.includes('/ads/library/async')) {
      try {
        const text = await response.text();
        const json = JSON.parse(text);
        const demographics = extractDemographicsFromApiResponse(json, adArchiveId, debug);

        if (demographics) {
          demographicsMap.set(adArchiveId, demographics);
        }
      } catch {
        // Response not parseable or body unavailable - continue
      }
    }
  };

  page.on('response', responseHandler);

  try {
    const adDetailUrl = `https://www.facebook.com/ads/library/?id=${adArchiveId}`;

    await page.goto(adDetailUrl, {
      waitUntil: 'networkidle2',
      timeout: 30000,
    });

    // Wait for demographic data to potentially load
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Try clicking "See ad details" button if present (EU transparency modal)
    // Use multiple selectors as fallback (research pitfall #5)
    const seeDetailsSelectors = [
      'div[role="button"][aria-label*="See ad details"]',
      'div[role="button"][aria-label*="see ad details"]',
      'span:has-text("See ad details")',
      '[data-testid="ad_details_button"]',
    ];

    for (const selector of seeDetailsSelectors) {
      try {
        const element = await page.$(selector);
        if (element) {
          await element.click();
          // Wait for modal content to load
          await new Promise(resolve => setTimeout(resolve, 1500));
          break;
        }
      } catch {
        // Selector failed, try next
      }
    }

    // Give a bit more time for any final API responses
    await new Promise(resolve => setTimeout(resolve, 500));

    return demographicsMap.get(adArchiveId) || null;

  } catch (error) {
    console.warn(`[demographics] Failed to scrape ad ${adArchiveId}:`, error);
    return null; // Graceful degradation (RELY-02)
  } finally {
    page.off('response', responseHandler);
  }
}
```

Key implementation notes:
- Uses the same network interception pattern as existing scraper
- Multiple selector fallbacks for "See ad details" button
- Returns null on any error (RELY-02: graceful handling)
- Removes listener in finally block to prevent memory leaks
- 30s timeout per ad (research pitfall #2: timeout management)
  </action>
  <verify>
`npx tsc --noEmit` passes. scrapeAdDemographics function exists in ad-library-scraper.ts.
  </verify>
  <done>
scrapeAdDemographics function navigates to ad detail pages, intercepts API responses, extracts demographics, and handles errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate demographic scraping into main function</name>
  <files>src/lib/ad-library-scraper.ts</files>
  <action>
Modify the main `scrapeAdLibrary` function to include demographic extraction.

1. Add a new parameter `scrapeDemo` to control whether demographics are scraped:

```typescript
export async function scrapeAdLibrary(
  adLibraryUrl: string,
  debug = false,
  options?: {
    scrapeDemographics?: boolean;  // Default: false (backward compatible)
    maxDemographicAds?: number;    // Default: 10
  }
): Promise<AdLibraryResponse | AdLibraryResultWithDemographics> {
```

2. After the existing scraping loop completes (after line ~350, where ads array is built), add demographic scraping:

```typescript
    // Convert to extended format if demographics requested
    if (options?.scrapeDemographics) {
      const maxAds = options.maxDemographicAds || 10;

      // Convert ads to AdWithMetrics for selection
      const adsWithMetrics: AdWithMetrics[] = ads.map(ad => ({
        adArchiveId: ad.adArchiveId || '',
        destinationUrl: ad.destinationUrl,
        startedRunning: ad.startedRunning,
        adCount: ad.adCount,
        // Note: reach data would come from API responses if available
        // For now, we use adCount as a proxy (more ads = more reach typically)
      }));

      // Select top performers (RELY-04)
      const topPerformers = selectTopPerformers(adsWithMetrics, maxAds);
      const topPerformerIds = new Set(topPerformers.map(tp => tp.adArchiveId));

      if (debug) {
        console.log(`[demographics] Selected ${topPerformers.length} top performers for analysis`);
      }

      // Scrape demographics for top performers
      let demographicsScraped = 0;
      let demographicsFailed = 0;
      const adDemographicsMap: Map<string, AdDemographics> = new Map();

      for (const performer of topPerformers) {
        if (!performer.adArchiveId) continue;

        try {
          // Add random delay between requests (research pitfall #3: detection)
          const delay = 1000 + Math.random() * 2000; // 1-3 seconds
          await new Promise(resolve => setTimeout(resolve, delay));

          const demographics = await scrapeAdDemographics(page, performer.adArchiveId, debug);

          if (demographics) {
            adDemographicsMap.set(performer.adArchiveId, demographics);
            demographicsScraped++;
            if (debug) {
              console.log(`[demographics] Extracted data for ad ${performer.adArchiveId}`);
            }
          } else {
            demographicsFailed++;
            if (debug) {
              console.log(`[demographics] No data for ad ${performer.adArchiveId}`);
            }
          }
        } catch (error) {
          demographicsFailed++;
          console.warn(`[demographics] Error scraping ad ${performer.adArchiveId}:`, error);
          // Continue with next ad (RELY-02)
        }
      }

      // Build extended result
      const extendedAds: AdDataWithDemographics[] = ads.map(ad => ({
        ...ad,
        demographics: ad.adArchiveId ? (adDemographicsMap.get(ad.adArchiveId) || null) : null,
      }));

      await browser.close();
      browser = null;

      return {
        success: true,
        pageId,
        pageName,
        ads: extendedAds,
        totalAdsFound: extendedAds.length,
        totalActiveAdsOnPage,
        demographicsScraped,
        demographicsFailed,
        topPerformersAnalyzed: topPerformers.length,
      } as AdLibraryResultWithDemographics;
    }
```

3. Ensure the page is NOT closed before demographic scraping (move browser.close() to after demographics if enabled).

4. Update the AdLibraryResponse type union to include the extended type:

```typescript
export type AdLibraryResponse = AdLibraryResult | AdLibraryResultWithDemographics | AdLibraryError;
```

Important: The existing behavior (no demographics) is preserved when options.scrapeDemographics is false or undefined.
  </action>
  <verify>
`npx tsc --noEmit` passes. scrapeAdLibrary accepts scrapeDemographics option and returns AdLibraryResultWithDemographics when enabled.
  </verify>
  <done>
scrapeAdLibrary function extended with demographic scraping capability. Backward compatible - demographics only scraped when explicitly requested. Top performers selected, demographics extracted with graceful error handling.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes
2. scrapeAdLibrary accepts `{ scrapeDemographics: true, maxDemographicAds: 10 }` options
3. When scrapeDemographics is true:
   - Top performers are selected via selectTopPerformers
   - Demographics are scraped from ad detail pages
   - Results include demographicsScraped/demographicsFailed counts
   - Errors don't crash the scraper (graceful handling)
4. When scrapeDemographics is false/undefined:
   - Existing behavior is unchanged (backward compatible)
</verification>

<success_criteria>
- EXTR-01: Age group percentages extracted (via ageGenderBreakdown in AdDemographics)
- EXTR-02: Gender percentages extracted (via ageGenderBreakdown in AdDemographics)
- EXTR-03: Country/region distribution extracted (via regionBreakdown in AdDemographics)
- RELY-02: Missing demographics handled gracefully (returns null, continues to next ad)
- RELY-04: Top performers auto-selected (selectTopPerformers called with maxDemographicAds limit)
- Backward compatible: Existing API calls without options work unchanged
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-demographic-extraction/02-03-SUMMARY.md`
</output>
