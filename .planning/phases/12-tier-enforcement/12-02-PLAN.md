---
phase: 12-tier-enforcement
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/app/api/facebook-ads/route.ts
autonomous: true

must_haves:
  truths:
    - "Free users cannot get more than 100 ads from API"
    - "Pro users can request up to 1000 ads"
    - "Tier enforcement is logged for debugging"
    - "API gracefully caps requests (doesn't reject)"
  artifacts:
    - path: "src/app/api/facebook-ads/route.ts"
      provides: "Tier-enforced Facebook ads API"
      contains: "getTierFromStatus"
  key_links:
    - from: "src/app/api/facebook-ads/route.ts"
      to: "src/lib/tiers.ts"
      via: "imports tier helpers"
      pattern: "import.*from.*tiers"
    - from: "src/app/api/facebook-ads/route.ts"
      to: "src/lib/subscription.ts"
      via: "imports getSubscriptionStatus"
      pattern: "import.*getSubscriptionStatus"
    - from: "src/app/api/facebook-ads/route.ts"
      to: "@/auth"
      via: "imports auth for session"
      pattern: "import.*auth.*from.*@/auth"
---

<objective>
Add server-side tier enforcement to the Facebook ads API.

Purpose: Critical security - ensures free users cannot bypass UI restrictions to get Pro-tier data.
Output: API route that validates and caps requests based on user's subscription tier.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-tier-enforcement/12-RESEARCH.md
@.planning/phases/12-tier-enforcement/12-01-SUMMARY.md
@src/app/api/facebook-ads/route.ts
@src/lib/tiers.ts
@src/lib/subscription.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tier enforcement to POST handler</name>
  <files>src/app/api/facebook-ads/route.ts</files>
  <action>
Modify the POST handler to enforce tier limits:

1. Add imports at top:
```typescript
import { auth } from '@/auth';
import { getSubscriptionStatus } from '@/lib/subscription';
import { getTierFromStatus, getMaxDepth, type TierName } from '@/lib/tiers';
```

2. After parsing body and before validation, add tier enforcement:
```typescript
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    let {
      adLibraryUrl,
      pageId,
      searchTerms,
      countries = ['NL'],
      limit = 100,  // Default to free tier limit
      activeStatus = 'ACTIVE',
    } = body;

    // --- TIER ENFORCEMENT ---
    // Get user's tier from session
    const session = await auth();
    let tier: TierName = 'free';

    if (session?.user?.email) {
      const status = await getSubscriptionStatus(session.user.email);
      tier = getTierFromStatus(status);
    }

    // Cap limit to tier maximum
    const maxAllowed = getMaxDepth(tier);
    if (limit > maxAllowed) {
      console.log(`[Tier] Capped limit from ${limit} to ${maxAllowed} for ${tier} tier`);
      limit = maxAllowed;
    }
    // --- END TIER ENFORCEMENT ---

    // Get access token (rest of existing code unchanged)
    const accessToken = body.accessToken || process.env.FACEBOOK_ACCESS_TOKEN;
    // ... rest of handler
```

Key design decisions:
- Default limit is 100 (free tier)
- Cap requests to tier maximum (graceful degradation, not rejection)
- Log enforcement for debugging
- Unauthenticated users get free tier limits
  </action>
  <verify>
Test with curl while logged out:
```bash
curl -X POST http://localhost:3000/api/facebook-ads \
  -H "Content-Type: application/json" \
  -d '{"adLibraryUrl":"https://facebook.com/ads/library/?view_all_page_id=123","limit":1000}'
```
Check server logs for "[Tier] Capped limit from 1000 to 100 for free tier"
  </verify>
  <done>POST handler enforces tier limits - free users capped to 100, pro users allowed up to 1000</done>
</task>

<task type="auto">
  <name>Task 2: Add tier enforcement to GET handler</name>
  <files>src/app/api/facebook-ads/route.ts</files>
  <action>
Add same tier enforcement to GET handler:

```typescript
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const pageId = searchParams.get('pageId');
  const searchTerms = searchParams.get('searchTerms') || searchParams.get('q');
  const countries = searchParams.get('countries')?.split(',') || ['NL'];
  let limit = parseInt(searchParams.get('limit') || '25', 10);

  // --- TIER ENFORCEMENT ---
  const session = await auth();
  let tier: TierName = 'free';

  if (session?.user?.email) {
    const status = await getSubscriptionStatus(session.user.email);
    tier = getTierFromStatus(status);
  }

  const maxAllowed = getMaxDepth(tier);
  if (limit > maxAllowed) {
    console.log(`[Tier] GET: Capped limit from ${limit} to ${maxAllowed} for ${tier} tier`);
    limit = maxAllowed;
  }
  // --- END TIER ENFORCEMENT ---

  const accessToken = process.env.FACEBOOK_ACCESS_TOKEN;
  // ... rest of handler
```

Note: GET handler is for simple queries. Same enforcement applies.
  </action>
  <verify>
Test with curl:
```bash
curl "http://localhost:3000/api/facebook-ads?pageId=123&limit=500"
```
Check logs for tier capping message.
  </verify>
  <done>GET handler also enforces tier limits consistently with POST</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] POST with limit=1000 gets capped to 100 for unauthenticated user
- [ ] GET with limit=500 gets capped to 100 for unauthenticated user
- [ ] Server logs show "[Tier] Capped limit" messages
</verification>

<success_criteria>
- Both POST and GET handlers enforce tier limits
- Free tier: max 100 ads
- Pro tier: max 1000 ads
- Requests gracefully capped (not rejected)
- Enforcement logged for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/12-tier-enforcement/12-02-SUMMARY.md`
</output>
