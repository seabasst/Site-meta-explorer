---
phase: 28-hook-extraction-engine
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/lib/facebook-api.ts
  - src/app/api/dashboard/snapshots/route.ts
  - src/app/api/brands/save/route.ts
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Hooks are persisted when a brand is saved for the first time"
    - "Hooks are persisted when a brand is re-analyzed (new snapshot)"
    - "Hooks are linked to the correct BrandSnapshot"
    - "All ad_creative_bodies elements are processed, not just [0]"
  artifacts:
    - path: "src/lib/facebook-api.ts"
      provides: "Raw ad creative bodies exposed on FacebookAdResult or via rawAds return"
    - path: "src/app/api/dashboard/snapshots/route.ts"
      provides: "Hook persistence during re-analysis"
      contains: "hookGroup.createMany"
    - path: "src/app/api/brands/save/route.ts"
      provides: "Hook persistence during initial brand save"
      contains: "hookGroup.createMany"
    - path: "src/app/page.tsx"
      provides: "Client sends hook data alongside snapshot during save"
  key_links:
    - from: "src/app/api/dashboard/snapshots/route.ts"
      to: "src/lib/hook-extractor.ts"
      via: "import extractHooksFromAds"
      pattern: "import.*extractHooksFromAds.*hook-extractor"
    - from: "src/app/api/brands/save/route.ts"
      to: "prisma.hookGroup.createMany"
      via: "persists hook groups in same transaction as snapshot"
      pattern: "hookGroup.createMany"
    - from: "src/app/page.tsx"
      to: "/api/brands/save"
      via: "sends hookGroups array in request body"
      pattern: "hookGroups"
---

<objective>
Wire hook extraction into both the save-brand and re-analysis flows so hooks are persisted to the database.

Purpose: This connects the hook extractor (Plan 01) to the two code paths that create BrandSnapshots. After this plan, every saved brand will have hook data available without re-analysis (HOOK-07).

Output: Modified API routes that persist hooks during brand save and re-analysis. Modified client page that sends hook data during save.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-hook-extraction-engine/28-RESEARCH.md
@.planning/phases/28-hook-extraction-engine/28-01-SUMMARY.md

@src/lib/hook-extractor.ts
@src/lib/facebook-api.ts
@src/lib/snapshot-builder.ts
@src/app/api/brands/save/route.ts
@src/app/api/dashboard/snapshots/route.ts
@src/app/page.tsx
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire hooks into re-analysis flow (snapshots route)</name>
  <files>src/app/api/dashboard/snapshots/route.ts, src/lib/facebook-api.ts</files>
  <action>
The snapshots POST route calls `fetchFacebookAds()` server-side which has access to raw `FacebookAdData[]` internally. Two changes needed:

**1. Expose raw ad creative bodies from `fetchFacebookAds`.**

In `src/lib/facebook-api.ts`, modify `FacebookApiResult` to include a new field:
```typescript
rawAdBodies: Array<{ id: string; ad_creative_bodies: string[]; eu_total_reach: number }>;
```

Populate this from the `allAds` array (line ~725 area) BEFORE the conversion to `FacebookAdResult[]`:
```typescript
const rawAdBodies = allAds.map(ad => ({
  id: ad.id,
  ad_creative_bodies: ad.ad_creative_bodies || [],
  eu_total_reach: ad.eu_total_reach || 0,
}));
```

Add `rawAdBodies` to the return object alongside `ads`, `totalAdsFound`, etc.

Do NOT modify the existing `FacebookAdResult` interface or the `ads` array conversion. The `rawAdBodies` field is a parallel data path specifically for hook extraction.

**2. Wire into snapshots POST route.**

In `src/app/api/dashboard/snapshots/route.ts`:
- Import `extractHooksFromAds` from `@/lib/hook-extractor`.
- After `fetchFacebookAds` returns, extract hooks: `const hookGroups = extractHooksFromAds(result.rawAdBodies);`
- Wrap the snapshot creation in a `$transaction` (it currently isn't in one). Inside the transaction:
  1. Create the BrandSnapshot (existing code, move into transaction).
  2. Create HookGroups: `await tx.hookGroup.createMany({ data: hookGroups.map(g => ({ hookText: g.hookText, normalizedText: g.normalizedText, frequency: g.frequency, totalReach: BigInt(g.totalReach), avgReachPerAd: g.avgReachPerAd, adIds: g.adIds, snapshotId: snapshot.id })) });`
- Update the `serializeSnapshot` function to also handle hook groups if included.

IMPORTANT: The existing `buildSnapshotFromApiResult` function does NOT need modification -- it works on `FacebookApiResult.ads` which is unchanged. The hook extraction works on `rawAdBodies` in parallel.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. If a Facebook access token is configured, test with: create a new snapshot for an existing tracked brand via the dashboard and verify hook_group rows appear in the database.
  </verify>
  <done>
Re-analysis (snapshots POST) persists hook groups alongside the snapshot in a single transaction. Hook data comes from all `ad_creative_bodies` elements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hooks into initial save-brand flow</name>
  <files>src/app/page.tsx, src/app/api/brands/save/route.ts</files>
  <action>
The save-brand flow is different: the client calls `/api/brands/save` with snapshot data. The client has access to the `apiResult` (which is a `FacebookApiResult`) -- and after Task 1, `apiResult.rawAdBodies` will be available.

**1. Modify client page (`src/app/page.tsx`).**

In `handleSaveBrand`:
- Import `extractHooksFromAds` from `@/lib/hook-extractor`.
- Before the fetch call, extract hooks: `const hookGroups = extractHooksFromAds(apiResult.rawAdBodies);`
- Add `hookGroups` to the request body alongside `snapshot`:
```typescript
body: JSON.stringify({
  facebookPageId: apiResult.pageId,
  pageName: apiResult.pageName || `Page ${apiResult.pageId}`,
  adLibraryUrl,
  snapshot: { ...snapshotData, totalReach: Number(snapshotData.totalReach) },
  hookGroups: hookGroups.map(g => ({
    hookText: g.hookText,
    normalizedText: g.normalizedText,
    frequency: g.frequency,
    totalReach: g.totalReach,
    avgReachPerAd: g.avgReachPerAd,
    adIds: g.adIds,
  })),
}),
```

**2. Modify save route (`src/app/api/brands/save/route.ts`).**

- Parse `hookGroups` from the request body (typed as `Array<{ hookText: string; normalizedText: string; frequency: number; totalReach: number; avgReachPerAd: number; adIds: string[] }> | undefined`).
- Inside the existing `$transaction`, after creating the BrandSnapshot (which already happens conditionally when `snapshot` is provided):
  - Get the snapshot ID from the created snapshot.
  - If `hookGroups` exists and has length > 0, create HookGroup rows:
    ```typescript
    await tx.hookGroup.createMany({
      data: hookGroups.map(g => ({
        hookText: g.hookText,
        normalizedText: g.normalizedText,
        frequency: g.frequency,
        totalReach: BigInt(g.totalReach),
        avgReachPerAd: g.avgReachPerAd,
        adIds: g.adIds,
        snapshotId: createdSnapshot.id,
      })),
    });
    ```
  - Store the created snapshot in a variable so its ID is accessible for hook creation.

IMPORTANT: The save route already uses a `$transaction`. Keep hooks inside the same transaction so they're atomic with the snapshot.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify the production build succeeds (catches any client/server boundary issues with importing hook-extractor into page.tsx). If Facebook access token is configured, test by analyzing a brand and saving it -- verify hook_group rows appear in the database.
  </verify>
  <done>
Initial brand save persists hook groups alongside the snapshot. Client extracts hooks from rawAdBodies and sends them to the save API. Both save and re-analysis flows now persist hooks.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. `FacebookApiResult` now includes `rawAdBodies` field
4. Snapshots POST route extracts hooks from rawAdBodies and persists via `hookGroup.createMany`
5. Save route accepts `hookGroups` from client and persists via `hookGroup.createMany`
6. Client page extracts hooks and includes them in save request body
7. Both flows use transactions for atomic snapshot + hooks creation
</verification>

<success_criteria>
- Re-analyzing a brand creates HookGroup rows linked to the new snapshot
- Saving a brand for the first time creates HookGroup rows linked to the initial snapshot
- All ad_creative_bodies elements are processed (not just [0])
- Hooks within the same ad are deduplicated by normalized text
- Hook groups with normalized text < 5 chars are filtered out
- Deleting a snapshot cascades to delete its hook groups
</success_criteria>

<output>
After completion, create `.planning/phases/28-hook-extraction-engine/28-02-SUMMARY.md`
</output>
