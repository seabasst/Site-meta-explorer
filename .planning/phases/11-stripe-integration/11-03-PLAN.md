---
phase: 11-stripe-integration
plan: 03
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/subscription.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Webhook endpoint for subscription state sync"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "Run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` and copy the webhook signing secret"
    dashboard_config:
      - task: "Configure Customer Portal"
        location: "Stripe Dashboard -> Settings -> Billing -> Customer portal"
        details: "Enable portal, configure allowed actions (cancel, update payment method)"

must_haves:
  truths:
    - "Webhook receives Stripe events and verifies signature"
    - "checkout.session.completed updates user to Pro status"
    - "customer.subscription.updated syncs status changes"
    - "customer.subscription.deleted marks user as cancelled"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with signature verification"
      exports: ["POST"]
    - path: "src/lib/subscription.ts"
      provides: "Subscription helper functions"
      exports: ["getSubscriptionStatus", "syncSubscriptionStatus"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "stripe.webhooks.constructEvent"
      via: "signature verification"
      pattern: "stripe\\.webhooks\\.constructEvent"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/subscription.ts"
      via: "sync functions"
      pattern: "syncSubscriptionStatus|handleCheckout"
    - from: "src/lib/subscription.ts"
      to: "prisma.user.update"
      via: "database sync"
      pattern: "prisma\\.user\\.update"
---

<objective>
Implement Stripe webhook handler for subscription state synchronization.

Purpose: Keep database subscription status in sync with Stripe. When users complete checkout, cancel, or resume subscriptions via Customer Portal, webhooks update the local database. This enables fast tier checks without API calls.

Output:
- Webhook route handler at src/app/api/webhooks/stripe/route.ts
- Subscription helper functions at src/lib/subscription.ts
- Handlers for checkout.session.completed, subscription.updated, subscription.deleted
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-stripe-integration/11-RESEARCH.md

# From Plan 01 (dependency)
@src/lib/stripe.ts
@src/lib/prisma.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscription helper functions</name>
  <files>
    - src/lib/subscription.ts
  </files>
  <action>
Create src/lib/subscription.ts with subscription management utilities:

```typescript
import { prisma } from '@/lib/prisma';
import { stripe } from '@/lib/stripe';
import type Stripe from 'stripe';

export type SubscriptionStatus = 'free' | 'pro' | 'past_due' | 'cancelled';

/**
 * Get subscription status from local database (fast)
 */
export async function getSubscriptionStatus(email: string): Promise<SubscriptionStatus> {
  const user = await prisma.user.findUnique({
    where: { email },
    select: { subscriptionStatus: true },
  });

  if (!user) return 'free';

  // Map database status to our simplified status
  switch (user.subscriptionStatus) {
    case 'pro':
    case 'active':
    case 'trialing':
      return 'pro';
    case 'past_due':
      return 'past_due';
    case 'cancelled':
    case 'canceled':
      return 'cancelled';
    default:
      return 'free';
  }
}

/**
 * Check if user has Pro access (active subscription)
 */
export async function isPro(email: string): Promise<boolean> {
  const status = await getSubscriptionStatus(email);
  return status === 'pro';
}

/**
 * Sync subscription status from Stripe to database
 * Called by webhook handlers
 */
export async function syncSubscriptionStatus(
  customerId: string,
  subscriptionId: string,
  status: Stripe.Subscription.Status
): Promise<void> {
  // Map Stripe status to our status
  let dbStatus: string;
  switch (status) {
    case 'active':
    case 'trialing':
      dbStatus = 'pro';
      break;
    case 'past_due':
      dbStatus = 'past_due';
      break;
    case 'canceled':
    case 'unpaid':
    case 'incomplete_expired':
      dbStatus = 'cancelled';
      break;
    default:
      dbStatus = 'free';
  }

  await prisma.user.updateMany({
    where: { stripeCustomerId: customerId },
    data: {
      subscriptionStatus: dbStatus,
      subscriptionId: status === 'canceled' ? null : subscriptionId,
    },
  });

  console.log(`[Subscription] Customer ${customerId} status updated to ${dbStatus}`);
}

/**
 * Handle successful checkout - create/update user subscription
 */
export async function handleCheckoutComplete(
  session: Stripe.Checkout.Session
): Promise<void> {
  const customerId = session.customer as string;
  const subscriptionId = session.subscription as string;
  const userId = session.metadata?.userId;

  if (!userId) {
    console.error('[Subscription] No userId in checkout session metadata');
    return;
  }

  // Update user with subscription info
  await prisma.user.update({
    where: { id: userId },
    data: {
      stripeCustomerId: customerId,
      subscriptionId: subscriptionId,
      subscriptionStatus: 'pro',
    },
  });

  console.log(`[Subscription] User ${userId} upgraded to Pro via checkout`);
}

/**
 * Handle subscription deletion (cancellation at period end)
 */
export async function handleSubscriptionDeleted(
  subscription: Stripe.Subscription
): Promise<void> {
  const customerId = subscription.customer as string;

  await prisma.user.updateMany({
    where: { stripeCustomerId: customerId },
    data: {
      subscriptionStatus: 'cancelled',
      subscriptionId: null,
    },
  });

  console.log(`[Subscription] Customer ${customerId} subscription cancelled`);
}
```

Key notes:
- getSubscriptionStatus reads from database (fast, no Stripe API call)
- isPro is a convenience function for tier checks
- syncSubscriptionStatus maps Stripe statuses to simplified local statuses
- handleCheckoutComplete uses userId from session metadata (set in checkout action)
- Uses console.log for observability (can upgrade to proper logging later)
  </action>
  <verify>
    - File exists at src/lib/subscription.ts
    - `npm run build` passes
    - Exports getSubscriptionStatus, isPro, syncSubscriptionStatus, handleCheckoutComplete, handleSubscriptionDeleted
  </verify>
  <done>
    - Subscription helper functions implemented
    - Database-backed status lookup (fast)
    - Status sync functions for webhook handlers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook handler</name>
  <files>
    - src/app/api/webhooks/stripe/route.ts
  </files>
  <action>
Create src/app/api/webhooks/stripe/route.ts:

```typescript
import { headers } from 'next/headers';
import { NextResponse } from 'next/server';
import type Stripe from 'stripe';
import { stripe } from '@/lib/stripe';
import {
  handleCheckoutComplete,
  syncSubscriptionStatus,
  handleSubscriptionDeleted,
} from '@/lib/subscription';

export async function POST(request: Request) {
  // CRITICAL: Use text() not json() for signature verification
  const body = await request.text();
  const headersList = await headers();
  const signature = headersList.get('stripe-signature');

  if (!signature) {
    console.error('[Webhook] Missing stripe-signature header');
    return NextResponse.json(
      { error: 'Missing signature' },
      { status: 400 }
    );
  }

  if (!process.env.STRIPE_WEBHOOK_SECRET) {
    console.error('[Webhook] STRIPE_WEBHOOK_SECRET not configured');
    return NextResponse.json(
      { error: 'Webhook secret not configured' },
      { status: 500 }
    );
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    console.error('[Webhook] Signature verification failed:', message);
    return NextResponse.json(
      { error: 'Invalid signature' },
      { status: 400 }
    );
  }

  console.log(`[Webhook] Received event: ${event.type}`);

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;
        if (session.mode === 'subscription') {
          await handleCheckoutComplete(session);
        }
        break;
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        await syncSubscriptionStatus(
          subscription.customer as string,
          subscription.id,
          subscription.status
        );
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        await handleSubscriptionDeleted(subscription);
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        const customerId = invoice.customer as string;
        console.log(`[Webhook] Payment failed for customer ${customerId}`);
        // Status will be updated via subscription.updated event (past_due)
        break;
      }

      default:
        console.log(`[Webhook] Unhandled event type: ${event.type}`);
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    console.error(`[Webhook] Error handling ${event.type}:`, message);
    // Still return 200 to prevent Stripe retry for processing errors
    // The event was received and verified, just failed to process
  }

  // Return 200 quickly to acknowledge receipt
  return NextResponse.json({ received: true });
}
```

CRITICAL implementation notes:
- Uses request.text() NOT request.json() - required for signature verification
- headers() is awaited (Next.js 15 async headers)
- Returns 200 even on processing errors to prevent retry loops
- Handles checkout.session.completed for new subscriptions
- Handles customer.subscription.updated for status changes (cancel, resume, payment issues)
- Handles customer.subscription.deleted for final cancellation
- Logs events for debugging
  </action>
  <verify>
    - File exists at src/app/api/webhooks/stripe/route.ts
    - `npm run build` passes
    - Route is accessible (test with curl after npm run dev):
      ```bash
      curl -X POST http://localhost:3000/api/webhooks/stripe -d '{}' -H "Content-Type: application/json"
      ```
      Should return 400 (missing signature) - confirms route is working
  </verify>
  <done>
    - Webhook route handler implemented at /api/webhooks/stripe
    - Signature verification using raw body
    - Handles checkout.session.completed, subscription.updated, subscription.deleted
    - Returns 200 quickly to Stripe
  </done>
</task>

</tasks>

<verification>
Run after all tasks complete:

```bash
# Build passes
npm run build

# Start dev server
npm run dev &

# Test webhook endpoint responds (should return 400 - missing signature)
curl -X POST http://localhost:3000/api/webhooks/stripe \
  -d '{"test": true}' \
  -H "Content-Type: application/json"

# Stop dev server
kill %1
```

Full webhook testing requires:
1. Install Stripe CLI: `brew install stripe/stripe-cli/stripe`
2. Login: `stripe login`
3. Forward events: `stripe listen --forward-to localhost:3000/api/webhooks/stripe`
4. Copy the webhook signing secret to .env.local as STRIPE_WEBHOOK_SECRET
5. Trigger test events: `stripe trigger checkout.session.completed`
</verification>

<success_criteria>
- src/lib/subscription.ts exports getSubscriptionStatus, isPro, syncSubscriptionStatus, handleCheckoutComplete, handleSubscriptionDeleted
- src/app/api/webhooks/stripe/route.ts handles POST requests
- Webhook verifies Stripe signature using raw body
- Handles key events: checkout.session.completed, subscription.updated, subscription.deleted
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-stripe-integration/11-03-SUMMARY.md`
</output>
