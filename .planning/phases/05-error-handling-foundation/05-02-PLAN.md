---
phase: 05-error-handling-foundation
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/lib/errors.ts
  - src/lib/retry.ts
  - src/lib/validation.ts
  - src/components/error/error-fallback.tsx
  - src/components/error/api-error-alert.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Technical API errors are translated to user-friendly messages"
    - "Failed requests can be retried with exponential backoff"
    - "URL validation schema catches invalid Ad Library URLs before submission"
  artifacts:
    - path: "src/lib/errors.ts"
      provides: "Error message mapper and error utilities"
      exports: ["getUserFriendlyMessage", "ApiError"]
    - path: "src/lib/retry.ts"
      provides: "Fetch with exponential backoff retry"
      exports: ["fetchWithRetry"]
    - path: "src/lib/validation.ts"
      provides: "Zod schemas for URL validation"
      exports: ["adLibraryUrlSchema"]
    - path: "src/components/error/error-fallback.tsx"
      provides: "Error boundary fallback UI with retry button"
      exports: ["ErrorFallback"]
    - path: "src/components/error/api-error-alert.tsx"
      provides: "API error display component with retry"
      exports: ["ApiErrorAlert"]
  key_links:
    - from: "src/lib/errors.ts"
      to: "src/components/error/error-fallback.tsx"
      via: "getUserFriendlyMessage import"
      pattern: "getUserFriendlyMessage"
    - from: "src/lib/errors.ts"
      to: "src/components/error/api-error-alert.tsx"
      via: "getUserFriendlyMessage import"
      pattern: "getUserFriendlyMessage"
    - from: "src/components/ui/alert.tsx"
      to: "src/components/error/*"
      via: "Alert component import"
      pattern: "from.*ui/alert"
---

<objective>
Create error handling utilities (error message mapper, retry logic, URL validation schema) and reusable error UI components (ErrorFallback, ApiErrorAlert) that translate technical errors to user-friendly messages and provide retry functionality.

Purpose: Establishes the error handling layer between API responses and user-facing UI. Covers requirements ERRH-01 (friendly messages), ERRH-02 (retry capability), and ERRH-03 (URL validation schema).

Output: Utility files in src/lib/, error components in src/components/error/
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-error-handling-foundation/05-RESEARCH.md
@.planning/phases/05-error-handling-foundation/05-01-SUMMARY.md
@src/lib/facebook-api.ts
@src/app/api/facebook-ads/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error utilities and message mapper</name>
  <files>
    - src/lib/errors.ts
    - src/lib/retry.ts
  </files>
  <action>
    Create src/lib/errors.ts with:

    ```typescript
    /**
     * Custom error class for API errors with additional context
     */
    export class ApiError extends Error {
      constructor(
        message: string,
        public readonly code?: string,
        public readonly status?: number,
        public readonly retryable: boolean = true
      ) {
        super(message);
        this.name = 'ApiError';
      }
    }

    /**
     * Maps technical error messages to user-friendly text.
     * Called by error display components to sanitize error output.
     */
    export function getUserFriendlyMessage(error: unknown): string {
      if (error instanceof ApiError) {
        // Handle known API errors
        if (error.code === 'RATE_LIMIT') {
          return 'Too many requests. Please wait a moment and try again.';
        }
        if (error.code === 'AUTH_ERROR') {
          return 'Unable to connect to Facebook. Please try again later.';
        }
      }

      if (error instanceof Error) {
        const msg = error.message.toLowerCase();

        // Facebook-specific errors
        if (msg.includes('facebook_access_token') || msg.includes('access token')) {
          return 'Unable to connect to Facebook. Please try again later.';
        }
        if (msg.includes('rate limit') || msg.includes('too many')) {
          return 'Too many requests. Please wait a moment and try again.';
        }
        if (msg.includes('page id') || msg.includes('view_all_page_id')) {
          return 'Invalid Ad Library URL. Please paste a URL with a page ID.';
        }

        // Network errors
        if (msg.includes('network') || msg.includes('fetch') || msg.includes('econnrefused')) {
          return 'Network connection issue. Please check your internet and try again.';
        }
        if (msg.includes('timeout') || msg.includes('timed out')) {
          return 'The request took too long. Please try again.';
        }

        // Generic server errors
        if (msg.includes('500') || msg.includes('internal server')) {
          return 'Something went wrong on our end. Please try again.';
        }
      }

      // Default fallback
      return 'Something went wrong. Please try again.';
    }

    /**
     * Determines if an error is retryable
     */
    export function isRetryableError(error: unknown): boolean {
      if (error instanceof ApiError) {
        return error.retryable;
      }

      if (error instanceof Error) {
        const msg = error.message.toLowerCase();
        // Non-retryable: validation errors, auth errors, 4xx client errors
        if (msg.includes('invalid url') || msg.includes('page id')) {
          return false;
        }
        // Retryable: network, timeout, server errors
        return true;
      }

      return true;
    }
    ```

    Create src/lib/retry.ts with:

    ```typescript
    interface RetryOptions {
      maxRetries?: number;
      baseDelay?: number;
      maxDelay?: number;
      onRetry?: (attempt: number, error: Error) => void;
    }

    /**
     * Wraps a fetch function with exponential backoff retry logic.
     * Includes jitter to prevent thundering herd problem.
     */
    export async function fetchWithRetry<T>(
      fetchFn: () => Promise<T>,
      options: RetryOptions = {}
    ): Promise<T> {
      const {
        maxRetries = 3,
        baseDelay = 1000,
        maxDelay = 10000,
        onRetry
      } = options;

      let lastError: Error | undefined;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fetchFn();
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));

          if (attempt === maxRetries) {
            throw lastError;
          }

          // Exponential backoff with jitter
          const jitter = Math.random() * 100;
          const delay = Math.min(
            baseDelay * Math.pow(2, attempt) + jitter,
            maxDelay
          );

          onRetry?.(attempt + 1, lastError);

          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      throw lastError ?? new Error('Unexpected: exceeded retry loop');
    }
    ```
  </action>
  <verify>
    - `cat src/lib/errors.ts` shows getUserFriendlyMessage function
    - `cat src/lib/retry.ts` shows fetchWithRetry function
    - `npx tsc --noEmit` passes with no errors
  </verify>
  <done>
    - errors.ts exports ApiError, getUserFriendlyMessage, isRetryableError
    - retry.ts exports fetchWithRetry with exponential backoff
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create URL validation schema</name>
  <files>
    - src/lib/validation.ts
  </files>
  <action>
    Create src/lib/validation.ts with Zod schema for Ad Library URL validation:

    ```typescript
    import { z } from 'zod';

    /**
     * Validation schema for Facebook Ad Library URLs.
     * Validates format, domain, and required parameters.
     */
    export const adLibraryUrlSchema = z.object({
      url: z
        .string()
        .min(1, 'Please enter an Ad Library URL')
        .url('Please enter a valid URL')
        .refine(
          (url) => {
            try {
              const parsed = new URL(url);
              return (
                parsed.hostname.includes('facebook.com') &&
                parsed.pathname.includes('/ads/library')
              );
            } catch {
              return false;
            }
          },
          { message: 'URL must be a Facebook Ad Library link' }
        )
        .refine(
          (url) => url.includes('view_all_page_id='),
          { message: 'URL must include a page ID (view_all_page_id parameter)' }
        ),
    });

    export type AdLibraryUrlInput = z.infer<typeof adLibraryUrlSchema>;

    /**
     * Validate URL synchronously for quick checks
     */
    export function validateAdLibraryUrl(url: string): { valid: boolean; error?: string } {
      const result = adLibraryUrlSchema.safeParse({ url });

      if (result.success) {
        return { valid: true };
      }

      const firstError = result.error.errors[0];
      return { valid: false, error: firstError?.message };
    }
    ```
  </action>
  <verify>
    - `cat src/lib/validation.ts` shows adLibraryUrlSchema
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - validation.ts exports adLibraryUrlSchema (Zod schema)
    - validation.ts exports validateAdLibraryUrl (sync helper)
    - Schema validates: non-empty, valid URL, facebook.com domain, /ads/library path, view_all_page_id param
  </done>
</task>

<task type="auto">
  <name>Task 3: Create error UI components</name>
  <files>
    - src/components/error/error-fallback.tsx
    - src/components/error/api-error-alert.tsx
  </files>
  <action>
    Create src/components/error/ directory.

    Create src/components/error/error-fallback.tsx:

    ```typescript
    'use client';

    import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
    import { AlertCircle, RefreshCcw } from 'lucide-react';
    import { getUserFriendlyMessage } from '@/lib/errors';

    interface ErrorFallbackProps {
      error: Error;
      resetErrorBoundary: () => void;
    }

    /**
     * Fallback UI for react-error-boundary.
     * Displays user-friendly error message with retry button.
     */
    export function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) {
      const message = getUserFriendlyMessage(error);

      return (
        <Alert variant="destructive" className="my-4">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription className="flex items-center justify-between gap-4">
            <span>{message}</span>
            <button
              onClick={resetErrorBoundary}
              className="inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-lg bg-[var(--bg-tertiary)] border border-[var(--border-subtle)] text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:border-[var(--border-default)] transition-colors"
            >
              <RefreshCcw className="h-4 w-4" />
              Retry
            </button>
          </AlertDescription>
        </Alert>
      );
    }
    ```

    Create src/components/error/api-error-alert.tsx:

    ```typescript
    'use client';

    import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
    import { AlertCircle, RefreshCcw } from 'lucide-react';
    import { getUserFriendlyMessage, isRetryableError } from '@/lib/errors';

    interface ApiErrorAlertProps {
      error: Error | string;
      onRetry?: () => void;
      className?: string;
    }

    /**
     * Displays API error with optional retry button.
     * Used for inline error display (not error boundary fallback).
     */
    export function ApiErrorAlert({ error, onRetry, className }: ApiErrorAlertProps) {
      const errorObj = typeof error === 'string' ? new Error(error) : error;
      const message = getUserFriendlyMessage(errorObj);
      const canRetry = onRetry && isRetryableError(errorObj);

      return (
        <Alert variant="destructive" className={className}>
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription className="flex items-center justify-between gap-4">
            <span>{message}</span>
            {canRetry && (
              <button
                onClick={onRetry}
                className="inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium rounded-lg bg-[var(--bg-tertiary)] border border-[var(--border-subtle)] text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:border-[var(--border-default)] transition-colors"
              >
                <RefreshCcw className="h-4 w-4" />
                Retry
              </button>
            )}
          </AlertDescription>
        </Alert>
      );
    }
    ```

    Note: Uses existing CSS variables from the project (--bg-tertiary, --border-subtle, etc.) for consistent styling.
  </action>
  <verify>
    - `ls src/components/error/` shows error-fallback.tsx, api-error-alert.tsx
    - `npx tsc --noEmit` passes
    - Components import from @/components/ui/alert correctly
  </verify>
  <done>
    - error-fallback.tsx exports ErrorFallback (for react-error-boundary)
    - api-error-alert.tsx exports ApiErrorAlert (for inline errors)
    - Both use getUserFriendlyMessage for human-readable errors
    - Both include retry buttons
    - Styling matches existing app design
  </done>
</task>

</tasks>

<verification>
1. TypeScript check: `npx tsc --noEmit` passes
2. All files exist:
   - src/lib/errors.ts
   - src/lib/retry.ts
   - src/lib/validation.ts
   - src/components/error/error-fallback.tsx
   - src/components/error/api-error-alert.tsx
3. Error utilities are importable and work:
   - getUserFriendlyMessage("rate limit exceeded") returns friendly message
   - fetchWithRetry can be called with a fetch function
   - adLibraryUrlSchema validates URLs correctly
</verification>

<success_criteria>
- getUserFriendlyMessage maps technical errors to user-friendly text (ERRH-01)
- fetchWithRetry implements exponential backoff with max 3 retries (ERRH-02)
- adLibraryUrlSchema validates Ad Library URLs with clear error messages (ERRH-03)
- ErrorFallback and ApiErrorAlert display friendly messages with retry buttons
- All components styled consistently with existing app
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling-foundation/05-02-SUMMARY.md`
</output>
